#+category: emacs
#+startup: content
* My Emacs Configuration
This is not a true literate configuration. Packages that demand complex configuration are configured in separate files. I am rewriting this configuration 
for a better understanding of my previous work and organizing it in a more sensible way.
** Table of contents                                              :noexport:
:PROPERTIES:
:TOC:      siblings
:END:
    -  [[#why][Why?]]
      -  [[#literate-configuration-in-org-mode][Literate configuration in Org mode]]
        -  [[#pros][Pros]]
        -  [[#cons][Cons]]
      -  [[#organizational-policies][Organizational policies]]
    -  [[#support-older-versions-of-emacs][Support older versions of Emacs]]
    -  [[#before-using-use-package][Before using use-package]]
    -  [[#overriding-defaults][Overriding defaults]]
    -  [[#keybindings-infrastructure][Keybindings infrastructure]]
      -  [[#repeatable-keys][Repeatable keys]]
      -  [[#per-mode-hydra][Per-mode hydra]]
      -  [[#generic-definer][Generic definer]]
      -  [[#definers-for-emacs-standard-prefix-keys][Definers for Emacs standard prefix keys]]
        -  [[#m-s-search][M-s: Search]]
        -  [[#m-g-jump][M-g: Jump]]
        -  [[#m-r-registers][M-r: Registers]]
        -  [[#f1-help][F1: Help]]
      -  [[#definers-for-non-standard-prefix-keys][Definers for non-standard prefix keys]]
        -  [[#bind-customization-c-x-esc-for-customization][bind-customization (C-x ESC) for customization]]
        -  [[#bind-user-c-c-for-miscellaneous-commands][bind-user (C-c) for miscellaneous commands]]
          -  [[#eval][eval]]
        -  [[#bind-generic-c--for-editing][bind-generic (C-.) for editing]]
        -  [[#bind-mode-c--for-major-mode-specific-commands][bind-mode (C-,) for major-mode-specific commands]]
        -  [[#bind-extra-help-f1-x-for-extra-help-commands][bind-extra-help (<f1> x) for extra help commands]]
        -  [[#bind-specific-help-f1-esc-for-specific-help-commands][bind-specific-help (<f1> ESC) for specific help commands]]
        -  [[#bind-system-f12-for-system-commands][bind-system (<f12>) for system commands]]
    -  [[#dependencies-for-other-packages][Dependencies for other packages]]
      -  [[#dashel][dash.el]]
      -  [[#ivy][Ivy]]
      -  [[#helm][Helm]]
      -  [[#org][Org]]
      -  [[#posframe][posframe]]
      -  [[#hydra][Hydra]]
      -  [[#ov-overlays][ov (overlays)]]
      -  [[#ts-date-time-library-by-alphapapa][ts (date-time library by alphapapa)]]
      -  [[#org-ql][org-ql]]
      -  [[#all-the-icons][all-the-icons]]
      -  [[#emacsql-sqlite][emacsql-sqlite]]
    -  [[#appearances][Appearances]]
      -  [[#theme][Theme]]
      -  [[#frame-elements][Frame elements]]
      -  [[#typeface][Typeface]]
    -  [[#a-bunch-of-useful-features][A bunch of useful features]]
      -  [[#chrome-os-support][Chrome OS support]]
      -  [[#frame-workflow][frame-workflow]]
      -  [[#terminal-and-shells][Terminal and shells]]
      -  [[#dired][Dired]]
      -  [[#crux-and-file-operations][Crux and file operations]]
      -  [[#buffer-management][Buffer management]]
      -  [[#magit][Magit]]
      -  [[#chrome][Chrome]]
      -  [[#company-completion][Company completion]]
      -  [[#yasnippet-and-auto-yasnippet][Yasnippet and auto-yasnippet]]
      -  [[#frequent-counsel-commands][Frequent counsel commands]]
      -  [[#avy][Avy]]
      -  [[#source-code-navigation][Source code navigation]]
      -  [[#outline-navigation][Outline navigation]]
      -  [[#outline-editing][Outline editing]]
      -  [[#referencing][Referencing]]
      -  [[#miscellaneous-commands][Miscellaneous commands]]
      -  [[#poporg][Poporg]]
      -  [[#window-management][Window management]]
      -  [[#visual-cues-and-extra-information-display][Visual cues and extra information display]]
      -  [[#dsls][DSLs]]
      -  [[#startup-buffer][Startup buffer]]
      -  [[#auto-saving-and-auto-git-commit][Auto saving and auto git-commit]]
      -  [[#org-web-tools-and-clipurl][org-web-tools and clipurl]]
      -  [[#highlighting-parts-of-source-code-and-focusing][Highlighting part(s) of source code and focusing]]
      -  [[#development-workflow][Development workflow]]
      -  [[#scratch-buffers][Scratch buffers]]
      -  [[#spell-checking-and-iedit][Spell checking and iedit]]
    -  [[#writing][Writing]]
      -  [[#multi-lingual-support][Multi-lingual support]]
      -  [[#graphviz][GraphViz]]
      -  [[#ditaa][Ditaa]]
      -  [[#exporting][Exporting]]
      -  [[#markdown][Markdown]]
    -  [[#programming-languages][Programming languages]]
      -  [[#emacs-lisp][Emacs Lisp]]
      -  [[#elixir][Elixir]]
      -  [[#haskell][Haskell]]
      -  [[#javascript][JavaScript]]
      -  [[#vue][Vue]]
      -  [[#web-mode][Web-mode]]
      -  [[#shell-scripts-bash][Shell scripts (bash)]]
      -  [[#elm][Elm]]
      -  [[#kotlin][Kotlin]]
      -  [[#nim][Nim]]
      -  [[#python][Python]]
      -  [[#rust][Rust]]
      -  [[#java][Java]]
    -  [[#emacs-applications][Emacs applications]]
      -  [[#getting-organised][Getting organised]]
        -  [[#jump-to-the-current-context][Jump to the current context]]
        -  [[#org-anywhere][Org anywhere]]
        -  [[#frame][Frame]]
        -  [[#org-agenda-keybindings][Org-agenda keybindings]]
      -  [[#beancount][Beancount]]
    -  [[#exwm][EXWM]]
    -  [[#meta][Meta]]
      -  [[#editing-the-commit-message][Editing the commit message]]

** Why?
*** Literate configuration in Org mode
Quite a few people maintain their Emacs configuration in a single literate Org file. I didn't like the idea, but I have to admit that it offers several benefits.
**** Pros
- You can quickly add a piece of configuration by refiling a subtree to the file from another location, e.g. your inbox Org file.
- You'll be exposed to a constant pressure to maintain a consistent structure, so the configuration will be more consistent.
- Each piece of configuration gets an explicit context.
**** Cons
- It is slightly more tedious to edit the literate config in Org mode. Rather than edit a file directly, you have to pop up an edit buffer for each piece of configuration you want to change.
- Revision history is lost when entries are reordered. This can be prevented by automatically sorting all headings before saving.
*** Organizational policies
I will combine both a literate configuration file and separate configuration files:

- The main configuration file is a single Org file containing babel source blocks. Simple package configurations can be put directly in the file.
- Complex package configurations are put in separate files, because they are likely to entail bugfixes and updates.
- However, certain kinds of configuration code to integrate those packages can be put in the Org configuration file. Keybindings and frame (frame-workflow) configurations are examples of such ones. They are inherently personal and often interrelated, so it doesn't make sense to treat them as independent ideas.

In principle, the main configuration file should be a thin layer of the Emacs configuration, even though they can contain some complex pieces.
** Support older versions of Emacs
=when-let= and =if-let= are available in Emacs 25.1, but they have been renamed to =when-let*= and =if-let*= in 26.1, which are correct names to describe their behaviours.

#+begin_src emacs-lisp
  (eval-and-compile
    (when (version< emacs-version "26")
      (with-no-warnings
        (defalias 'when-let* #'when-let)
        (function-put #'when-let* 'lisp-indent-function 1)
        (defalias 'if-let* #'if-let)
        (function-put #'if-let* 'lisp-indent-function 2))))
#+end_src

** Before using =use-package=
#+begin_src emacs-lisp
  (setq-default enable-local-variables :safe)
#+end_src

These packages are required in other use-package directives declared in this
configuration.

#+begin_src emacs-lisp
  (use-package el-patch
    :custom
    (el-patch-enable-use-package-integration t))
#+end_src

Save efforts to configure individual variable files using no-littering

#+begin_src emacs-lisp
(use-package no-littering
  :init
  (setq no-littering-var-directory
        (expand-file-name ".cache" user-emacs-directory)))
#+end_src

Use the executable path from the shell

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns x))
  :init
  (exec-path-from-shell-initialize))
#+end_src

Use diminish to reduce clutters from the modeline. This adds support for =:diminish= keyword:

#+begin_src emacs-lisp
  (use-package diminish
    :disabled t
    :init
    (diminish 'auto-revert-mode)
    (diminish 'outline-minor-mode)
    (diminish 'flyspell-mode))
#+end_src

Deprecated: Allow installation of system packages via use-package

#+begin_src emacs-lisp
  (use-package system-packages)

  (use-package use-package-ensure-system-package)
#+end_src

#+begin_src emacs-lisp
  (use-package use-package-company
    :straight (use-package-company :host github :repo "Foltik/use-package-company"))
#+end_src

** Overriding defaults
These settings don't depend on external dependencies, so they should be applied earlier.

#+begin_src emacs-lisp
  (akirak/require 'setup-defaults t)
#+end_src

** Keybindings infrastructure
Use general.el to define keybindings. It has made several improvements over
bind-key, including a built-in support for which-key.

#+begin_src emacs-lisp
  (use-package general)
#+end_src

This also adds support for =:general= keyword in use-package directives

Allow use of =:wk= keyword in general.el keybinding definitions

#+begin_src emacs-lisp
  (akirak/require 'setup-which-key t)
#+end_src

*** Repeatable keys

Hopefully, defrepeater is soon going to be integrated with general

#+begin_src emacs-lisp
  (akirak/require 'setup-defrepeater t)
#+end_src

*** Per-mode hydra
As it is hard to remember workflow for every programming language, I've decided to set up a hydra for each programming language I use. Frequently-used commands specific to a major mode should be added to the hydra for its language. All mode hydras should share the same keybinding, which is currently ~C-d~.

I added a function =akirak/bind-mode-hydra= which binds a per-mode hydra for on the key. It takes the name of the major mode and binds the key to =akirak/MODE-hydra/body=. This is not a precisely keybinding definer but plays a somewhat similar role.

#+begin_src emacs-lisp
  (defcustom akirak/mode-hydra-key (kbd "C-c d")
    "Key sequence to access the hydra for the current mode.")

  (defun akirak/bind-mode-hydra (mode &optional hydra-function)
    (let ((map (intern (concat (symbol-name mode) "-map"))))
      (define-key (symbol-value map) akirak/mode-hydra-key
        (or hydra-function
            (intern (format "akirak/%s-hydra/body" mode))))))
#+end_src
*** Generic definer
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-key)
#+end_src
*** Definers for Emacs standard prefix keys
**** M-s: Search
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-search :prefix "M-s")
  (define-obsolete-function-alias 'akirak/bind-search-map
    'akirak/bind-search)
#+end_src
**** M-g: Jump
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-jump :prefix "M-g")
#+end_src
**** M-r: Registers
#+begin_src emacs-lisp
  (general-def
    "M-r" (general-simulate-key "C-x r"))
#+end_src

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-register :prefix "C-x r")
  (define-obsolete-function-alias 'akirak/bind-register-map
    'akirak/bind-register)
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-register "M-r" #'ivy-resume)
#+end_src
**** F1: Help
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-help :prefix "<f1>")
#+end_src
*** Definers for non-standard prefix keys
**** bind-customization (C-x ESC) for customization
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:39]
:END:
I often need to tweak Emacs while I am using it.

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-customization :prefix "C-x ESC")

  (define-obsolete-function-alias 'akirak/bind-customize-map
    'akirak/bind-customization)
#+end_src

There are not so many commands that need to be add to the map:

#+begin_src emacs-lisp
  (akirak/bind-customization
    "" '(nil :wk "customize")
    "f" #'customize-face-other-window
    "g" #'customize-group-other-window
    "l" #'counsel-find-library
    "p" '((lambda () (interactive)
            (if (featurep 'straight)
                (call-interactively 'straight-use-package)
              (package-list-packages)))
          :wk "packages")
    "s" #'customize-set-value
    "v" #'customize-variable-other-window)
#+end_src
**** bind-user (C-c) for miscellaneous commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:40]
:END:

~C-c~ is reserved for the user:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-user :prefix "C-c")
#+end_src
***** eval
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:41]
:END:
Add a prefix for keybindings to eval commands:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-eval :prefix "C-c e")
  (define-obsolete-function-alias 'akirak/bind-eval-map 'akirak/bind-eval)
#+end_src
**** bind-generic (C-.) for editing
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:41]
:END:
Generic prefix key for editing commands:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-generic :prefix "C-."
    :prefix-map 'akirak/generic-prefix-map)
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-generic
    "a" '(nil :wk "align")
    "b" '(nil :wk "barf")
    "i" '(nil :wk "insert")
    "j" '(nil :wk "join")
    "k" '(nil :wk "kill")
    "m" '(nil :wk "mark")
    "o" #'split-line                      ; Originally C-M-o
    "r" '(nil :wk "re")
    "s" '(nil :wk "slurp/split")
    "u" '(nil :wk "splice/unwrap"))

  (general-create-definer akirak/bind-align :prefix "C-. a"
    :prefix-map 'akirak/align-prefix-map)
  (general-create-definer akirak/bind-barf :prefix "C-. b"
    :prefix-map 'akirak/barf-prefix-map)
  (general-create-definer akirak/bind-insert :prefix "C-. i"
    :prefix-map 'akirak/insert-prefix-map)
  (general-create-definer akirak/bind-join :prefix "C-. j"
    :prefix-map akirak/join)
  (general-create-definer akirak/bind-kill :prefix "C-. k"
    :prefix-map 'akirak/kill-prefix-map)
  (general-create-definer akirak/bind-mark :prefix "C-. m"
    :prefix-map 'akirak/mark-prefix-map)
  (general-create-definer akirak/bind-split :prefix "C-. s"
    :prefix-map 'akirak/split-prefix-map)
  (general-create-definer akirak/bind-replace :prefix "C-. r"
    :prefix-map 'akirak/replace-prefix-map)
  (general-create-definer akirak/bind-unwrap :prefix "C-. u"
    :prefix-map 'akirak/unwrap-prefix-map)
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-kill
   "f" 'flush-lines
   "l" 'delete-blank-lines)
#+end_src
**** bind-mode (C-,) for major-mode-specific commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:42]
:END:
Prefix for mode-specific keys:

#+begin_src emacs-lisp
(defconst akirak/mode-prefix-key "C-,")
(general-create-definer akirak/bind-mode :prefix akirak/mode-prefix-key)
#+end_src
**** bind-extra-help (<f1> x) for extra help commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:42]
:END:
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-extra-help :prefix "<f1>x")
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-extra-help
    "c" #'describe-char
    "f" #'counsel-describe-face)
#+end_src
**** bind-specific-help (<f1> ESC) for specific help commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:43]
:END:
Also create a prefix for specific help commands, e.g. =info= and =man=:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-specific-help :prefix "<f1> ESC")
#+end_src
**** bind-system (<f12>) for system commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:43]
:END:
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-system :prefix "<f12>"
    :prefix-map 'akirak/system-map)
#+end_src

** Dependencies for other packages
:PROPERTIES:
:TOC:      1
:CUSTOM_ID: dependencies
:ID:       ee01d40d-51af-4598-825e-dc79e4e0c394
:END:
These packages may be required by other packages loaded later on.
*** dash.el
Quite a few packages depend on =dash.el= and/or =dash-functional.el=, so they should be loaded in the very beginning of package declarations.

#+begin_src emacs-lisp
  (use-package dash)
  (use-package dash-functional)
#+end_src
*** Ivy
#+begin_src emacs-lisp
  (akirak/require 'setup-ivy t)
#+end_src
*** Helm
#+begin_src emacs-lisp
  (akirak/require 'setup-helm t)
#+end_src
*** Org
**** Org-babel
#+begin_src emacs-lisp
  (akirak/require 'setup-org-babel t)
#+end_src
To add support for a language in org-babel, add the following configuration:

- Add =(LANG . t)= to =org-babel-load-languages= in =:init= section of a =use-package= directive.
- If necessary, add a custom mapping to =org-src-lang-modes=.
****  Org-export
Some exporters, e.g. =ox-hugo=, depend on =ox-org=, and it is tedious to add =(require 'ox-org)= to all of their configurations, so I will load it immediately after =ox= is loaded.

#+begin_src emacs-lisp
  (use-package ox
    :after org
    :straight nil
    :config
    ;; Workaround for preventing a loading error in some exporter packages
    (require 'ox-org))
#+end_src
*** posframe
:PROPERTIES:
:CREATED_TIME: [2019-03-31 Sun 01:55]
:END:
#+begin_src emacs-lisp
  (use-package posframe)
#+end_src
*** Hydra
#+begin_src emacs-lisp
  (akirak/require 'setup-hydra)
#+end_src
*** ov (overlays)
#+begin_src emacs-lisp
(use-package ov
  :straight (ov :host github :repo "ShingoFukuyama/ov.el"))
#+end_src
*** ts (date-time library by alphapapa)
#+begin_src emacs-lisp
  (use-package ts
    :straight (ts :host github :repo "alphapapa/ts.el"))
#+end_src
*** org-ql
#+begin_src emacs-lisp
  (use-package org-ql
    :straight (org-ql :host github :repo "alphapapa/org-ql"))
#+end_src
*** all-the-icons
#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src
*** emacsql-sqlite
=emacsql-sqlite= depends on a pre-built binary executable. To use this feature, you have to build dependencies beforehand using [[file:Makefile::emacsql-sqlite:][a make task]].

#+begin_src emacs-lisp
  (akirak/require 'setup-emacsql-sqlite)
#+end_src
** Appearances
*** Theme
- You can set the default theme using the customization interface.
- You can override the default theme at startup with =--theme= command line option, e.g. =emacs --theme poet=.

#+begin_src emacs-lisp
  (defcustom akirak/default-theme-module 'setup-dracula-theme
    "Symbol of a module to load the default theme."
    :type '(choice (const :tag "Dracula (dark bg)" setup-dracula-theme)
                   (const :tag "Poet (light bg, especially nice for Org mode)" setup-poet-theme)
                   (const :tag "Kaolin Light (light bg)" setup-kaolin-light-theme)
                   (const :tag "Doom Solarized Light" setup-doom-solarized-light-theme)
                   (const :tag "McCarthy (light bg)" setup-mccarthy-theme))
    :group 'akirak)

  (defun akirak/set-theme-from-command-line (_arg)
    (if-let ((theme-name (pop command-line-args-left)))
        (or (akirak/require (intern (concat "setup-" theme-name "-theme")))
            (progn
              (message "%s failed to load. Fallback to the default theme.")
              (akirak/require akirak/default-theme-module)))
      (error "--theme must be followed by a theme name")))

  (add-to-list 'command-switch-alist
               '("--theme" . akirak/set-theme-from-command-line))

  ;; If the option is not given, load the default theme.
  (unless (member "--theme" (cdr command-line-args))
    (akirak/require akirak/default-theme-module))
#+end_src

*** Frame elements
Due to consistency with other applications on computer, my eyes tend to stay in the upper area of a window. I prefer relying on the header line extensively rather than the modeline.

#+begin_src emacs-lisp
  (akirak/require 'setup-header-line t) ; Hide the mode line and use the header line
  (akirak/require 'setup-feebleline t)  ; Display extra information in the echo area
  (akirak/require 'setup-frame-title t) ; Configure a custom frame title format
#+end_src
*** Typeface
This modules configures extra face attributes for typography. 
This feature is enabled if and only if a window system is
available.

#+begin_src emacs-lisp
  (cond
   ((window-system)
    (akirak/require 'setup-typeface))
   ((daemonp)
    (defun akirak/init-typeface ()
      (let ((frame (make-frame `((window-system . ,(cl-case system-type
                                                     (darwin 'ns)
                                                     (windows-nt 'w32)
                                                     (t 'x)))
                                 (visibility . nil)))))
        (unwind-protect
            (progn
              (defun akirak/ad-around-font-family-list (orig &optional _frame)
                (funcall orig frame))
              (advice-add 'font-family-list :around #'akirak/ad-around-font-family-list)
              (akirak/require 'setup-typeface)
              (advice-remove 'font-family-list #'akirak/ad-around-font-family-list))
          (delete-frame frame))))
    (add-hook 'after-init-hook #'akirak/init-typeface)))
#+end_src

If your operating system supports Docker, you can use [[https://github.com/akirak/fonts-container][fonts-container]] to install fonts used in the module.
** A bunch of useful features
:PROPERTIES:
:TOC:      1
:ID:       7042f1a9-0cd3-4769-acda-a98d200f569b
:CUSTOM_ID: enhancements
:END:
#+begin_src emacs-lisp
  ;; desktop needs to be configured in prior to other convenience packages
  (akirak/require 'setup-desktop)
  (akirak/require 'setup-meta)
  (akirak/require 'setup-misc)
#+end_src

*** Chrome OS support
I use Emacs on Crostini on Chrome OS, and Emacs needs some workarounds when it runs on Chrome OS:
#+begin_src emacs-lisp
  (akirak/require 'setup-chromeos t :when (akirak/running-on-crostini-p))
#+end_src
*** frame-workflow
[[https://github.com/akirak/frame-workflow][frame-workflow]] is my package originally written for providing named workspaces in EXWM. 

#+begin_src emacs-lisp
  (akirak/require 'setup-frame-workflow t) ; Ensure loading frame-workflow

  (general-def "C-M-g" #'frame-workflow-prefix-map)
#+end_src

*** Terminal and shells
#+begin_src emacs-lisp
  (akirak/require 'setup-terminal t)
#+end_src

#+begin_src emacs-lisp
  (general-def
    "<f6>" 'akirak/shell-new
    "C-x T" #'akirak/shell-toggle-dedicated)
#+end_src
**** Frame

#+begin_src emacs-lisp
  (akirak/define-frame-workflow "terminal"
    :key "t"
    :make-frame
    '(frame-purpose-make-frame :modes '(term-mode
                                        eshell-mode
                                        shell-mode))
    :layout
    '(ibuffer-sidebar-show-sidebar))
#+end_src

*** Dired
#+begin_src emacs-lisp
  (general-def "C-x C-j" #'dired-jump)
#+end_src
**** Hydra
#+begin_src emacs-lisp
  (defhydra akirak/dired-mode-hydra ()
    ""
    ("r" dired-rsync))

  (akirak/bind-mode-hydra 'dired-mode)
#+end_src
**** Frame
#+begin_src emacs-lisp
  (akirak/define-frame-workflow "dired"
    :key "d"
    :make-frame
    '(frame-purpose-make-mode-frame 'dired-mode)
    :layout
    '(when (fboundp 'ibuffer-sidebar-show-sidebar)
       (ibuffer-sidebar-show-sidebar)))
#+end_src

*** Crux and file operations
#+begin_src emacs-lisp
  (general-def
    "C-x D" #'crux-delete-file-and-buffer
    "C-x R" #'crux-rename-file-and-buffer
    "C-x S" #'sudo-find-file
    "C-x x" #'crux-open-with)
#+end_src

*** Buffer management
#+begin_src emacs-lisp
  ;; buffer management
  (general-def
    "<f5>" 'revert-buffer
    "C-x k" #'kill-this-buffer  
    "C-x C-b" #'ibuffer)
#+end_src
*** Magit
The following packages extend the display of =magit-status=:

- magit-todos

#+begin_src emacs-lisp
  (general-def "<f7>" #'magit-status)
#+end_src
**** magit-todos
#+begin_src emacs-lisp
  (use-package magit-todos :after (magit hl-todo)
    :straight (magit-todos :host github :repo "alphapapa/magit-todos")
    :config
    (magit-todos-mode 1))
#+end_src
**** GitHub workflow
#+begin_src emacs-lisp
  (akirak/require 'setup-github)
#+end_src

I used magithub, but I'm trying to avoid it whenever possible.
I sometimes use it for forking a repository, but I plan on removing it in the future.

=forge.el= seems useful, but I will disable the package for now, since straight.el doesn't seem to install the package properly (possibly related [[https://github.com/raxod502/straight.el/issues/336][#336]]). 

=github-review.el= looks useful for reviewing pull requests on GitHub, but I seldom receive pull requests, so I have never used it.
**** Cloning Git repositories
[[file:setup/setup-git-clone.el::(defun%20akirak/git-clone%20(url)][akirak/git-clone]] function lets you clone a Git repository to a designated location from a Git repository, a GitHub repository page, or a path on GitHub (=account/name=). It is integrated with ivy-clipurl, so you can clone a Git repository from its web page URL in the clipboard.
*** Chrome
#+begin_src emacs-lisp
(use-package atomic-chrome
  :disabled t
  :init
  (atomic-chrome-start-server))
#+end_src
*** Company completion
#+begin_src emacs-lisp
(general-def :package 'company :keymaps 'company-mode-map
  "M-/" #'company-complete)
#+end_src
*** Yasnippet and auto-yasnippet

I prefer using =ivy-yasnippet= for choosing a snippet:

#+begin_src emacs-lisp
  (akirak/bind-user "y" 'ivy-yasnippet)
  (akirak/bind-register "M-n" 'yas-new-snippet)
#+end_src

=auto-yasnippet= is convenient for temporary snippets:

#+begin_src emacs-lisp
  (akirak/bind-register-map
    "a" 'aya-create
    "e" 'aya-expand)
#+end_src

=aya-open-line= is the fastest way to expand a snippet if you know its name. It behaves like =open-line= if the word before the point is not registered as a snippet:

#+begin_src emacs-lisp
  (general-def "C-o" 'aya-open-line)
#+end_src

Yankpad is more useful in writing, so bind a key to =yankpad-insert=:

#+begin_src emacs-lisp
  (akirak/bind-user "p" 'akirak/yankpad-insert)
#+end_src
*** Frequent counsel commands                                  :navigation:
#+begin_src emacs-lisp
  (general-def
    "C-x p" #'counsel-projectile
    "C-x /" #'counsel-rg
    "C-x F" #'counsel-recentf
    "C-x L" #'counsel-locate)
#+end_src
*** Avy                                                        :navigation:
#+begin_src emacs-lisp
  (akirak/require 'setup-avy)

  (akirak/bind-key "C-'" 'avy-goto-char-timer)

  (general-unbind "C-'" :keymaps 'org-mode-map :package 'org)
#+end_src

=link-hint= is not part of =avy= package, but it is covenient for following a link:

#+begin_src emacs-lisp
  (akirak/bind-jump "f" 'akirak/link-hint-open-link)
#+end_src
*** Source code navigation                                     :navigation:

I used =dumb-jump=, but now I will try =smart-jump= instead.

The following keybindings have been replaced with smart-jump correspondents:

#+begin_src emacs-lisp
  ;; Use smart-jump instead.
  ;; (akirak/bind-jump
  ;;   "." #'dumb-jump-go
  ;;   "," #'dumb-jump-back)
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-search "i" 'counsel-imenu)

  (akirak/bind-search :package 'org :keymaps 'org-mode-map
    "i" 'counsel-org-goto)
#+end_src

*** Outline navigation                                         :navigation:
#+begin_src emacs-lisp
  (akirak/bind-jump :package 'outline :keymaps 'outline-minor-mode-map
    "h" 'outline-up-heading)

  (akirak/bind-jump  :package 'org :keymaps 'org-mode-map
    "h" 'org-up-element)
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-search "o" 'counsel-outline)
  (akirak/bind-search :package 'org :keymaps 'org-mode-map
    "o" 'counsel-org-goto)
#+end_src

*** Outline editing                                              :outlines:
#+begin_src emacs-lisp
  (general-def :keymaps 'outline-minor-mode-map :package 'outshine
    "M-RET" 'outshine-insert-heading)
  (general-unbind :keymaps 'lispy-mode-map :package 'lispy "M-RET")
#+end_src
*** Referencing                                               :referencing:
#+begin_src emacs-lisp
  (akirak/bind-specific-help
    "d" #'helm-dash)

  ;; "a" #'helm-dash-activate-docset
  ;; "d" #'helm-dash-at-point
  ;; "+" #'helm-dash-install-docset
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-specific-help
    "i" #'helm-info
    "m" #'woman)
#+end_src
*** Miscellaneous commands
**** Switching to an Org window
#+begin_src emacs-lisp
  (defvar org-select-window-last-window nil)

  (defun org-select-window (arg)
    (interactive "P")
    (if arg
        (progn
          (when org-select-window-last-window
            (select-window org-select-window-last-window)
            (setq org-select-window-last-window nil)))
      (let* ((wlist (window-list))
             (i0 (-elem-index (selected-window) wlist))
             (queue (append (-slice wlist (1+ i0))
                            (-take i0 wlist)))
             (w (-find (lambda (w)
                         (with-current-buffer (window-buffer w)
                           (derived-mode-p 'org-mode)))
                       queue)))
        (if w
            (progn
              (unless (derived-mode-p 'org-mode)
                (setq org-select-window-last-window (selected-window)))
              (select-window w))
          (message "No other org window in this frame")))))
#+end_src
**** modi/org-split-block
#+begin_src emacs-lisp
  (use-package modi-org-split-block
    :straight nil
    :load-path "contrib/modi")
  (akirak/bind-key :package 'org :keymaps 'org-mode-map
    [remap org-meta-return] 'modi/org-meta-return)
#+end_src
*** Poporg
:PROPERTIES:
:CREATED_TIME: [2018-12-29 Sat 19:51]
:ID:       e76069bd-d9b2-488a-a5c8-9f2410240396
:END:

Use poporg rather than outorg.

- [X] Add poporg package
- [X] Remap keys

#+begin_src emacs-lisp
  (use-package poporg)
  (akirak/bind-user "'" 'poporg-dwim)
  ;; The default keybindings in poporg-mode-map are not intuitive to me,
  (akirak/bind-key :keymaps 'poporg-mode-map
    "C-c C-c" 'poporg-edit-exit
    "C-x C-s" 'poporg-update-and-save)
#+end_src
*** Window management
:PROPERTIES:
:CREATED_TIME: [2018-12-31 Mon 05:04]
:END:
#+begin_src emacs-lisp
(akirak/bind-user
  "u" #'winner-undo-repeat)
#+end_src

I created a hydra for managing frames and windows.

#+begin_src emacs-lisp
  (akirak/bind-key "M-o" #'ace-window)
  ;; You can also display the help from the start
  ;; (akirak/bind-key "M-o" #'aw-show-dispatch-help)
  (general-unbind :keymaps 'lispy-mode-map :package 'lispy "M-o")
#+end_src
*** Visual cues and extra information display

Additional visual cues can increase productivity, but they can be noisy at the same time. Therefore I need to justify each package added to my config.

**** Beacon
I often lose sight of the cursor when I switch to another window, so this is necessary.
#+begin_src emacs-lisp
  (use-package beacon                     ; Highlight the cursor on certain events
    :config
    (beacon-mode 1))
#+end_src
**** Rainbow-delimiters
This is especially useful in editing Lisp code.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters         ; Colourize parentheses in source code
    :hook
    ((lisp-mode
      elixir-mode
      haskell-mode
      ) . rainbow-delimiters-mode))
#+end_src
**** Dimmer
This package makes the focused window stands out by dimming the other windows. However, the dimness should be kept small to make referenced text readable.
#+begin_src emacs-lisp
  (akirak/require 'setup-dimmer)
#+end_src
**** Git-gutter
This lets you know which parts of the buffers are modified since the last commit.
#+begin_src emacs-lisp
  (use-package git-gutter
    :diminish git-gutter-mode
    :init
    (global-git-gutter-mode))

  ;; NOTE: There is no git-gutter-mode-map
  (akirak/bind-jump
    "j" 'git-gutter:next-hunk
    "k" 'git-gutter:previous-hunk)
#+end_src
**** Highlight-indent-guides
This is helpful in programming languages that depend on indentation levels.
#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :init
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))
#+end_src
**** Fill-column-indicator
Visualise (usually) 80 columns.
#+begin_src emacs-lisp
  (use-package fill-column-indicator
    :init
    (add-hook 'prog-mode-hook 'fci-mode))
#+end_src
**** Whitespace
Visualise unnecessary, extra whitespace characters in source code.

See [[file:setup/setup-whitespace.el::(use-package%20whitespace][setup-whitespace.el]].

*** DSLs
**** Meson                                                 :build__system:

#+begin_src emacs-lisp
  (use-package meson-mode)
#+end_src
**** YAML                                        :configuration__language:

#+begin_src emacs-lisp
  (akirak/require 'setup-yaml)
#+end_src
***** Ansible
Ansible is based on YAML.

#+begin_src emacs-lisp
  ;; (akirak/require 'setup-ansible)
#+end_src
**** Dockerfile                                  :configuration__language:

#+begin_src emacs-lisp
  (akirak/require 'setup-dockerfile)
#+end_src
**** Nix                                         :configuration__language:
#+begin_src emacs-lisp
  (akirak/require 'setup-nix)
#+end_src
*** Startup buffer
By default, =*Messages*= buffer is shown at startup.

#+begin_src emacs-lisp
  (akirak/require 'setup-initial-buffer)
#+end_src

*** Auto saving and auto git-commit

Files are automatically saved on certain events by =super-save-mode=:

#+begin_src emacs-lisp
  (akirak/require 'setup-super-save)
#+end_src

Some files are automatically committed to their contained repositories.

[[file:setup/setup-git-auto-commit.el]]
*** org-web-tools and clipurl
[[https://github.com/alphapapa/org-web-tools][org-web-tools]] is handy, but commands in the package often fail to retrieve a proper URL I want to operate on. Therefore I created =clipurl= package to pick a URL from the kill ring.

#+begin_src emacs-lisp
  (akirak/require 'setup-org-web-tools)

  (defun akirak/insert-previous-url-link ()
    (interactive)
    (if current-prefix-arg
	(call-interactively 'ivy-clipurl)
      ;; Use ivy-clipurl in place of org-web-tools-insert-link.
      (let ((ivy-clipurl-default-action 'clipurl-insert-url-dwim)
	    (ivy-clipurl-prompt "Choose a URL to insert: "))
	(call-interactively 'ivy-clipurl))
      ;; (call-interactively 'org-web-tools-insert-link-for-url)
      ))

  (akirak/bind-user "w" 'akirak/insert-previous-url-link)
#+end_src

To visit a URL, use =browse-url-at-point=:

#+begin_src emacs-lisp
  (akirak/bind-user "o" #'browse-url-at-point)
#+end_src

*** Highlighting part(s) of source code and focusing
:PROPERTIES:
:CREATED_TIME: [2019-01-25 Fri 22:47]
:END:

- bm (visual bookmarks)
- symbol-overlay

#+begin_src emacs-lisp
(akirak/bind-user
  "b" 'helm-bm
  "m" 'bm-toggle
  "s" 'symbol-overlay-put)
#+end_src

#+begin_src emacs-lisp
  (general-def
    "C-x n" #'akirak/narrow-or-widen-dwim)
#+end_src

*** Development workflow
#+begin_src emacs-lisp
  (general-def
    "<f9>" 'recompile)

  (general-def
    "C-x t" #'helm-tail)
#+end_src
*** Scratch buffers
#+begin_src emacs-lisp
;; Development
(akirak/bind-user
  "i" 'scratch)
#+end_src
*** Spell checking and iedit                               :editor:writing:
Note that iedit works with [[file:setup/setup-multiple-cursors.el][multiple-cursors]]. You can first select all the occurrences of a symbol using multiple-cursors and then edit them using iedit.

#+begin_src emacs-lisp
  (general-def "C-;" 'akirak/iedit-or-flyspell)

  (defun akirak/iedit-or-flyspell ()
    "With a prefix argument, run iedit in the function. Otherwise, run iedit or flyspell.

  With a prefix argument, call `unpackaged/iedit-scoped'.
  Otherwise, call `unpackaged/iedit-or-flyspell'."
    (interactive)
    (if current-prefix-arg
	(unpackaged/iedit-scoped)
      (unpackaged/iedit-or-flyspell)))

  (defhydra akirak/flyspell-hydra ()
    "flyspell"
    ("n" flyspell-goto-next-error)
    ("c" flyspell-correct-word))

  (defun akirak/turn-on-flyspell-mode-in-text-mode ()
    (when (derived-mode-p 'text-mode)
      (flyspell-mode-on)))

  (advice-add 'akirak/flyspell-hydra/body
	      :before 'akirak/turn-on-flyspell-mode-in-text-mode)

  (akirak/bind-generic "f" 'akirak/flyspell-hydra/body)
#+end_src
** Writing
:PROPERTIES:
:TOC:      1
:END:
Set the basic options for org-mode:

#+begin_src emacs-lisp
  (akirak/require 'setup-org t)

  ;; org-starter should be loaded after org is loaded
  (akirak/require 'setup-org-starter)
#+end_src
*** Multi-lingual support
:PROPERTIES:
:CREATED_TIME: [2019-03-23 Sat 16:36]
:END:

A modules for supporting a natural language should follow the naming convention of =setup-LANGUAGE-SYSTEM=. For example, =setup-chinese-pyim= is a Chinese support through =pyim.el=.

You can customize a list of modules for supported languages through the following variable. This setting can be done per machine, so different machines can support different languages:

#+begin_src emacs-lisp
  (defcustom akirak/enabled-language-supports
    nil
    "List of enabled modules for supporting natural languages other than English.

  These modules are loaded at startup.

  I also suggest you set `default-input-method' to your preferred
  input method in the environment."
    :group 'akirak
    :type '(set (const :tag "Japanese/日本語 (mozc)" setup-japanese-mozc)
		(const :tag "Chinese/简体中文 (pyim)" setup-chinese-pyim))
    :set (lambda (sym value)
	   (set sym value)
	   (dolist (module value)
	     (akirak/require module))
	   (when (= 1 (length value))
	     (setq default-input-method
		   (string-remove-prefix "setup-" (symbol-name (car value)))))))
#+end_src

I don't set the default input method here. Set =default-input-method= in your =custom-file=. 

*** GraphViz
#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)

  (use-package ob-dot
    :after ob
    :straight nil
    :init
    (require 'ox-org)
    (add-to-list 'org-babel-load-languages '(dot . t))
    (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot)))
#+end_src
*** Ditaa
#+begin_src emacs-lisp
  (use-package ob-ditaa
    :after ob
    :straight nil
    :init
    (add-to-list 'org-babel-load-languages '(ditaa . t)))
#+end_src
*** Exporting
**** ox-hugo
#+begin_src emacs-lisp
  (akirak/require 'setup-org-hugo)
#+end_src
*** Markdown
Markdown is supported as well:

#+begin_src emacs-lisp
  (akirak/require 'setup-markdown)
#+end_src

** Programming languages
:PROPERTIES:
:TOC:      1
:END:
Ideally, this section should be a portfolio of my skills.
*** Emacs Lisp
#+begin_src emacs-lisp
(akirak/require 'setup-emacs-lisp)
#+end_src
**** Hydra
#+begin_src emacs-lisp
  (defhydra akirak/emacs-lisp-mode-hydra (:exit t :hint nil)
    "
  emacs-lisp

  ^^Point/last sexp  ^^Buffer          ^^Help/doc
  ^^---------------  ^^--------------  ----------
  _._ helpful        _e_ eval          _i_ info symbol
  _m_ macroexp       _l_ package-lint  _s_ suggest

  "
    ("i" counsel-info-lookup-symbol)
    ("s" suggest)
    ("." helpful-at-point)
    ("e" akirak/eval-buffer-or-load-file)
    ("l" package-lint-current-buffer)
    ("m" pp-macroexpand-last-sexp)
    ("q" nil "quit"))

  (akirak/bind-mode-hydra 'emacs-lisp-mode)
#+end_src
**** Frame
#+begin_src emacs-lisp
  (akirak/define-frame-workflow "emacs-lisp"
    :key "e"
    :make-frame '(frame-purpose-make-mode-frame 'emacs-lisp-mode))
#+end_src
**** Frame for the Emacs config
#+begin_src emacs-lisp
  (akirak/define-frame-workflow "emacs-config"
    :key "C"
    :layout
    '(progn
       (delete-other-windows)
       (let ((default-directory user-emacs-directory))
         (frame-workflow-magit-same-window)))
    :make-frame
    '(frame-purpose-make-directory-frame user-emacs-directory))
#+end_src
**** Makel
I find [[https://github.com/vermiculus/emake.el][emake]] difficult to use, so I have experimentally switched to [[https://gitlab.petton.fr/DamienCassou/makel][makel]].

*** Elixir

#+begin_src emacs-lisp
  (akirak/require 'setup-elixir)
#+end_src

*** Haskell

#+begin_src emacs-lisp
  (akirak/require 'setup-haskell)
#+end_src

*** JavaScript
#+begin_src emacs-lisp
  (akirak/require 'setup-javascript)
  (akirak/require 'setup-json)
#+end_src

*** Vue
:PROPERTIES:
:CREATED_TIME: [2019-04-03 Wed 22:45]
:END:
#+begin_src emacs-lisp
  (akirak/require 'setup-vue)
#+end_src
*** Web-mode
#+begin_src emacs-lisp
  (akirak/require 'setup-web-mode)
#+end_src

#+begin_src emacs-lisp
  (akirak/require 'setup-restclient)
#+end_src
*** Shell scripts (bash)

#+begin_src emacs-lisp
  (use-package company-shell
    :init
    (add-to-list 'company-backends 'company-shell))
#+end_src

*** Elm

#+begin_src emacs-lisp
  (akirak/require 'setup-elm)
#+end_src

*** Kotlin

#+begin_src emacs-lisp
  (akirak/require 'setup-kotlin)
#+end_src

*** Nim

#+begin_src emacs-lisp
  (akirak/require 'setup-nim)
#+end_src

*** Python

#+begin_src emacs-lisp
  (akirak/require 'setup-python)
#+end_src

*** Rust
:PROPERTIES:
:CREATED_TIME: [2019-01-01 Tue 15:54]
:ID:       e15d3e74-9760-4e6f-ba18-9cb337758247
:END:
:LOGBOOK:
CLOCK: [2019-01-01 Tue 15:54]--[2019-01-01 Tue 15:56] =>  0:02
:END:
#+begin_src emacs-lisp
  (use-package rust-mode)
#+end_src

*** Java
#+begin_src emacs-lisp
  (defcustom akirak/java-support-module 'setup-java-lsp
    "Module for supporting Java."
    :type '(choice (const setup-java-lsp)
                   (const setup-java-meghanada)))

  (add-hook 'java-mode-hook (lambda () (require akirak/java-support-module)))

#+end_src
** Emacs applications
*** Getting organised
**** Jump to the current context
Use =my-goto= function to locate the current context.

 #+begin_src emacs-lisp
   (akirak/bind-key "M-g M-j" #'counsel-org-clock-goto)
 #+end_src
**** Org anywhere
#+begin_src emacs-lisp
  (akirak/bind-search "M-o" #'helm-org-rifle-known-files)
  (akirak/bind-jump "M-o" #'org-starter-find-file-by-key)
  (akirak/bind-user
    "c" #'org-capture
    "l" 'org-store-link
    "n" #'counsel-org-capture-string)
#+end_src
**** Frame
:PROPERTIES:
:ID:       5c418e70-a0a0-4d86-81a5-3186abb038ee
:END:

#+begin_src emacs-lisp
  (akirak/define-frame-workflow "org"
    :key "o"
    :layout '(progn
               (org-starter-load-all-known-files)
               (when (fboundp #'ibuffer-sidebar-show-sidebar)
                 (ibuffer-sidebar-show-sidebar)
                 (with-current-buffer (ibuffer-sidebar-buffer (selected-frame))
                   (ibuffer-projectile-set-filter-groups)
                   (ibuffer-update nil))))
    :make-frame '(frame-purpose-make-mode-frame 'org-mode))
#+end_src

**** Org-agenda keybindings                              :Emacs:Org__Mode:
:PROPERTIES:
:CREATED_TIME: [2019-01-19 Sat 12:22]
:END:
:LOGBOOK:
CLOCK: [2019-01-19 Sat 12:22]--[2019-01-19 Sat 12:25] =>  0:03
:END:

#+begin_src emacs-lisp
  (general-def org-agenda-mode-map :package 'org-agenda
    "M-n" #'org-agenda-drag-line-forward
    "M-p" #'org-agenda-drag-line-backward)
#+end_src
*** Beancount
#+begin_src emacs-lisp
  (akirak/require 'setup-beancount)
#+end_src
** EXWM
#+begin_src emacs-lisp
  (when (member "--exwm" command-line-args)
    (akirak/require 'setup-exwm)
    (exwm-enable))

  (add-to-list 'command-switch-alist '("--exwm" . (lambda (_) nil)))
#+end_src
** Meta
*** Editing the commit message
If the beginning of the commit message is "[NAME]", then jump to the end of the line.

#+begin_src emacs-lisp
  (defun akirak/jump-in-commit-message ()
    (when (and (equal (file-name-nondirectory (buffer-file-name))
                      "COMMIT_EDITMSG")
               (looking-at (rx bol "[" (+ (not (any space "]"))) "]" (* space) eol)))
      (end-of-line 1)))
#+end_src
*** Ignore
:PROPERTIES:
:TOC:      ignore
:END:
# Local Variables:
# before-save-hook: org-make-toc
# org-id-link-to-org-use-id: nil
# End:
