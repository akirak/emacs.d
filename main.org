#+category: emacs
#+startup: content
* My Emacs Configuration
This is not a true literate configuration. Packages that demand complex configuration are configured in separate files. I am rewriting this configuration 
for a better understanding of my previous work and organizing it in a more sensible way.
** Table of contents                                              :noexport:
:PROPERTIES:
:TOC:      siblings
:END:
    -  [[#why][Why?]]
      -  [[#literate-configuration-in-org-mode][Literate configuration in Org mode]]
        -  [[#pros][Pros]]
        -  [[#cons][Cons]]
      -  [[#organizational-policies][Organizational policies]]
    -  [[#support-older-versions-of-emacs][Support older versions of Emacs]]
    -  [[#before-using-use-package][Before using use-package]]
    -  [[#overriding-defaults][Overriding defaults]]
    -  [[#keybindings-infrastructure][Keybindings infrastructure]]
      -  [[#repeatable-keys][Repeatable keys]]
      -  [[#per-mode-hydra][Per-mode hydra]]
      -  [[#generic-definer][Generic definer]]
      -  [[#definers-for-emacs-standard-prefix-keys][Definers for Emacs standard prefix keys]]
      -  [[#definers-for-non-standard-prefix-keys][Definers for non-standard prefix keys]]
      -  [[#other-custom-key-definitions][Other custom key definitions]]
    -  [[#dependencies-for-other-packages][Dependencies for other packages]]
      -  [[#built-in][Built-in]]
      -  [[#dashel][dash.el]]
      -  [[#ivy][Ivy]]
      -  [[#helm][Helm]]
      -  [[#posframe][posframe]]
      -  [[#hydra][Hydra]]
      -  [[#ov-overlays][ov (overlays)]]
      -  [[#ts-date-time-library-by-alphapapa][ts (date-time library by alphapapa)]]
      -  [[#org-ql][org-ql]]
      -  [[#all-the-icons][all-the-icons]]
      -  [[#emacsql-sqlite][emacsql-sqlite]]
      -  [[#nix-env-install][nix-env-install]]
      -  [[#desktop-integration][desktop integration]]
      -  [[#language-detection][language-detection]]
    -  [[#platform-workarounds][Platform workarounds]]
      -  [[#chrome-os-support][Chrome OS support]]
    -  [[#appearances][Appearances]]
      -  [[#theme][Theme]]
      -  [[#frame-elements][Frame elements]]
      -  [[#typeface][Typeface]]
      -  [[#visual-enhancements][Visual enhancements]]
        -  [[#page-break-lines][page-break-lines]]
        -  [[#color-support-in-terminal-and-compilation-buffers][Color support in terminal and compilation buffers]]
        -  [[#colorize-color-names][Colorize color names]]
        -  [[#fontify-face][fontify-face]]
        -  [[#centralizing-window-contents][Centralizing window contents]]
    -  [[#a-bunch-of-useful-features][A bunch of useful features]]
      -  [[#pretty-hydras][Pretty hydras]]
      -  [[#frame-workflow][frame-workflow]]
      -  [[#terminal-and-shells][Terminal and shells]]
      -  [[#dired][Dired]]
      -  [[#crux-and-file-operations][Crux and file operations]]
      -  [[#buffer-management][Buffer management]]
      -  [[#git][Git]]
      -  [[#project-management][Project management]]
      -  [[#web-browser-integration][Web browser integration]]
      -  [[#company-completion][Company completion]]
      -  [[#templates][Templates]]
      -  [[#frequent-counsel-commands][Frequent counsel commands]]
      -  [[#avy][Avy]]
      -  [[#source-code-navigation][Source code navigation]]
      -  [[#outline-editing][Outline editing]]
      -  [[#referencing][Referencing]]
      -  [[#general-tools-for-editing-source-code][General tools for editing source code]]
      -  [[#editing-specific-types-of-formats][Editing specific types of formats]]
      -  [[#miscellaneous-commands][Miscellaneous commands]]
      -  [[#poporg][Poporg]]
      -  [[#window-management][Window management]]
      -  [[#visual-cues-and-extra-information-display][Visual cues and extra information display]]
      -  [[#startup-buffer][Startup buffer]]
      -  [[#auto-saving-and-auto-git-commit][Auto saving and auto git-commit]]
      -  [[#org-web-tools-and-clipurl][org-web-tools and clipurl]]
      -  [[#highlighting-parts-of-source-code-and-focusing][Highlighting part(s) of source code and focusing]]
      -  [[#development-workflow][Development workflow]]
      -  [[#scratch-buffers][Scratch buffers]]
      -  [[#spell-checking-and-iedit][Spell checking and iedit]]
      -  [[#integrating-language-servers][Integrating language servers]]
      -  [[#optimization][Optimization]]
    -  [[#writing][Writing]]
      -  [[#multi-lingual-support][Multi-lingual support]]
      -  [[#utilities][Utilities]]
      -  [[#using-org-mode][Using Org mode]]
      -  [[#markdown][Markdown]]
    -  [[#programming-languages][Programming languages]]
      -  [[#elixir][Elixir]]
      -  [[#elm][Elm]]
      -  [[#emacs-lisp][Emacs Lisp]]
      -  [[#haskell][Haskell]]
      -  [[#java][Java]]
      -  [[#javascript][JavaScript]]
      -  [[#kotlin][Kotlin]]
      -  [[#nim][Nim]]
      -  [[#python][Python]]
      -  [[#rust][Rust]]
      -  [[#shell-scripts-bash][Shell scripts (bash)]]
      -  [[#vbscript][VBScript]]
      -  [[#vue][Vue]]
      -  [[#web-mode][Web-mode]]
    -  [[#dsls][DSLs]]
      -  [[#bats][Bats]]
      -  [[#dhall][Dhall]]
      -  [[#dockerfile][Dockerfile]]
      -  [[#graphviz][GraphViz]]
      -  [[#nix][Nix]]
      -  [[#pug][Pug]]
      -  [[#systemd][Systemd]]
    -  [[#emacs-applications][Emacs applications]]
      -  [[#getting-organised][Getting organised]]
        -  [[#global-bindings-related-to-org-mode][Global bindings related to Org mode]]
          -  [[#on-navigation][On navigation]]
        -  [[#org-journal][Org Journal]]
        -  [[#frame][Frame]]
        -  [[#org-agenda-keybindings][Org-agenda keybindings]]
      -  [[#beancount][Beancount]]
      -  [[#system-tools][System tools]]
        -  [[#system-services][System services]]
        -  [[#mounting-disks][Mounting disks]]
        -  [[#disk-usage][Disk usage]]
    -  [[#multiple-major-modes][Multiple major modes]]
      -  [[#polymode][polymode]]
    -  [[#exwm][EXWM]]
      -  [[#slack][Slack]]
      -  [[#visual-studio-code][Visual Studio Code]]
      -  [[#web-browser][Web browser]]
    -  [[#meta][Meta]]
      -  [[#synchronizing-my-configuration-repositories][Synchronizing my configuration repositories]]
      -  [[#sort-entries-in-this-file][Sort entries in this file]]

** Why?
*** Literate configuration in Org mode
Quite a few people maintain their Emacs configuration in a single literate Org file. I didn't like the idea, but I have to admit that it offers several benefits.
**** Pros
- You can quickly add a piece of configuration by refiling a subtree to the file from another location, e.g. your inbox Org file.
- You'll be exposed to a constant pressure to maintain a consistent structure, so the configuration will be more consistent.
- Each piece of configuration gets an explicit context.
**** Cons
- It is slightly more tedious to edit the literate config in Org mode. Rather than edit a file directly, you have to pop up an edit buffer for each piece of configuration you want to change.
- Revision history is lost when entries are reordered. This can be prevented by automatically sorting all headings before saving.
*** Organizational policies
I will combine both a literate configuration file and separate configuration files:

- The main configuration file is a single Org file containing babel source blocks. Simple package configurations can be put directly in the file.
- Complex package configurations are put in separate files, because they are likely to entail bugfixes and updates.
- However, certain kinds of configuration code to integrate those packages can be put in the Org configuration file. Keybindings and frame (frame-workflow) configurations are examples of such ones. They are inherently personal and often interrelated, so it doesn't make sense to treat them as independent ideas.

In principle, the main configuration file should be a thin layer of the Emacs configuration, even though they can contain some complex pieces.
** Support older versions of Emacs
=when-let= and =if-let= are available in Emacs 25.1, but they have been renamed to =when-let*= and =if-let*= in 26.1, which are correct names to describe their behaviours.

#+begin_src emacs-lisp
  (eval-and-compile
    (when (version< emacs-version "26")
      (with-no-warnings
        (defalias 'when-let* #'when-let)
        (function-put #'when-let* 'lisp-indent-function 1)
        (defalias 'if-let* #'if-let)
        (function-put #'if-let* 'lisp-indent-function 2))))
#+end_src

** Before using =use-package=
#+begin_src emacs-lisp
(akirak/require 'setup-gc)
#+end_src

#+begin_src emacs-lisp
  (setq-default enable-local-variables :safe)
#+end_src

These packages are required in other use-package directives declared in this
configuration.

#+begin_src emacs-lisp
  (use-package el-patch
    :custom
    (el-patch-enable-use-package-integration t))
#+end_src

Activate =package.el= for loading built-in packages from nixpkgs:

#+begin_src emacs-lisp
  (require 'package)
  (package-initialize 'noactivate)
#+end_src

Package-specific configuration files, including snippets, are kept in [[https://github.com/akirak/emacs-config-library][a separate repository]], not in this repository. 

#+begin_src emacs-lisp
  (defcustom akirak/no-littering-use-my-etc-library t
    "Whether to use my configuration file library in ~/lib/emacs as `no-littering-etc-directory'.")

  (use-package no-littering
    :init
    (when akirak/no-littering-use-my-etc-library
      (let ((dir "~/lib/emacs"))
        (when (or (file-directory-p dir)
                  (and (yes-or-no-p "~/lib/emacs does not exist. Clone it from GitHub?")
                       (= 0 (call-process-shell-command
                             (format "git clone %s %s"
                                     "https://github.com/akirak/emacs-config-library.git"
                                     (shell-quote-argument (expand-file-name dir)))
                             nil nil nil))))
          (setq no-littering-etc-directory dir)))))
#+end_src

Use the executable path from the shell

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :disabled t
  :if (memq window-system '(mac ns x))
  :init
  (exec-path-from-shell-initialize))
#+end_src

Use diminish to reduce clutters from the modeline. This adds support for =:diminish= keyword:

#+begin_src emacs-lisp
  (use-package diminish
    :disabled t
    :init
    (diminish 'auto-revert-mode)
    (diminish 'outline-minor-mode)
    (diminish 'flyspell-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package use-package-company
    ;; Originally written by Foltik, but I use my fork
    :straight (use-package-company :host github :repo "akirak/use-package-company"))
#+end_src

** Overriding defaults
These settings don't depend on external dependencies, so they should be applied earlier.

#+begin_src emacs-lisp
  (akirak/require 'setup-defaults t)
#+end_src

** Keybindings infrastructure
:PROPERTIES:
:TOC:      1
:END:
Use general.el to define keybindings. It has made several improvements over
bind-key, including a built-in support for which-key.

#+begin_src emacs-lisp
  (use-package general)
#+end_src

This also adds support for =:general= keyword in use-package directives

Allow use of =:wk= keyword in general.el keybinding definitions

#+begin_src emacs-lisp
  (akirak/require 'setup-which-key t)
#+end_src

*** Repeatable keys

Hopefully, defrepeater is soon going to be integrated with general

#+begin_src emacs-lisp
  (akirak/require 'setup-defrepeater t)
#+end_src

*** Per-mode hydra
As it is hard to remember workflow for every programming language, I've decided to set up a hydra for each programming language I use. Frequently-used commands specific to a major mode should be added to the hydra for its language. All mode hydras should share the same keybinding, which is currently ~C-d~.

I added a function =akirak/bind-mode-hydra= which binds a per-mode hydra for on the key. It takes the name of the major mode and binds the key to =akirak/MODE-hydra/body=. This is not a precisely keybinding definer but plays a somewhat similar role.

#+begin_src emacs-lisp
  (defcustom akirak/mode-hydra-key (kbd "C-c d")
    "Key sequence to access the hydra for the current mode.")

  (defun akirak/bind-mode-hydra (mode &optional hydra-function)
    (let ((map (intern (concat (symbol-name mode) "-map"))))
      (define-key (symbol-value map) akirak/mode-hydra-key
        (or hydra-function
            (intern (format "akirak/%s-hydra/body" mode))))))
#+end_src
*** Generic definer
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-key)
#+end_src
*** Definers for Emacs standard prefix keys
**** M-s: Search
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-search :prefix "M-s")
  (define-obsolete-function-alias 'akirak/bind-search-map
    'akirak/bind-search)
#+end_src
**** M-g: Jump
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-jump :prefix "M-g")
#+end_src
**** M-r: Registers
#+begin_src emacs-lisp
  (general-def
    "M-r" (general-simulate-key "C-x r"))
#+end_src

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-register :prefix "C-x r")
  (define-obsolete-function-alias 'akirak/bind-register-map
    'akirak/bind-register)
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-register "M-r" #'ivy-resume)
#+end_src
**** F1: Help
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-help :prefix "<f1>")
#+end_src
*** Definers for non-standard prefix keys
**** bind-customization (C-x ESC) for customization
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:39]
:END:
I often need to tweak Emacs while I am using it.

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-customization :prefix "C-x ESC")

  (define-obsolete-function-alias 'akirak/bind-customize-map
    'akirak/bind-customization)
#+end_src

There are not so many commands that need to be add to the map:

#+begin_src emacs-lisp
  (akirak/bind-customization
    "" '(nil :wk "customize")
    "f" #'customize-face-other-window
    "o" #'customize-group-other-window
    "l" #'counsel-find-library
    "p" '((lambda () (interactive)
            (if (featurep 'straight)
                (call-interactively 'straight-use-package)
              (package-list-packages)))
          :wk "packages")
    "s" #'customize-set-value
    "v" #'customize-variable-other-window)
#+end_src
**** bind-user (C-c) for miscellaneous commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:40]
:END:

~C-c~ is reserved for the user:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-user :prefix "C-c")
#+end_src
***** eval
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:41]
:END:
Add a prefix for keybindings to eval commands:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-eval :prefix "C-c e")
  (define-obsolete-function-alias 'akirak/bind-eval-map 'akirak/bind-eval)
#+end_src
**** bind-generic (C-.) for editing
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:41]
:END:
Generic prefix key for editing commands:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-generic :prefix "C-."
    :prefix-map 'akirak/generic-prefix-map)
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-generic
    "a" '(nil :wk "align")
    "b" '(nil :wk "barf")
    "f" '(nil :wk "format")
    "i" '(nil :wk "insert")
    "j" '(nil :wk "join")
    "k" '(nil :wk "kill")
    "m" '(nil :wk "mark")
    "o" '(nil :wk "origami")
    "r" '(nil :wk "rename/refactor")
    "s" '(nil :wk "slurp/split")
    "u" '(nil :wk "splice/unwrap"))

  (general-create-definer akirak/bind-align :prefix "C-. a"
    :prefix-map 'akirak/align-prefix-map)
  (general-create-definer akirak/bind-barf :prefix "C-. b"
    :prefix-map 'akirak/barf-prefix-map)
  (general-create-definer akirak/bind-insert :prefix "C-. i"
    :prefix-map 'akirak/insert-prefix-map)
  (general-create-definer akirak/bind-join :prefix "C-. j"
    :prefix-map akirak/join)
  (general-create-definer akirak/bind-kill :prefix "C-. k"
    :prefix-map 'akirak/kill-prefix-map)
  (general-create-definer akirak/bind-mark :prefix "C-. m"
    :prefix-map 'akirak/mark-prefix-map)
  (general-create-definer akirak/bind-split :prefix "C-. s"
    :prefix-map 'akirak/split-prefix-map)
  (general-create-definer akirak/bind-replace :prefix "C-. r"
    :prefix-map 'akirak/replace-prefix-map)
  (general-create-definer akirak/bind-unwrap :prefix "C-. u"
    :prefix-map 'akirak/unwrap-prefix-map)
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-kill
   "f" 'flush-lines
   "l" 'delete-blank-lines)
#+end_src
**** bind-mode (C-,) for major-mode-specific commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:42]
:END:
Prefix for mode-specific keys:

#+begin_src emacs-lisp
(defconst akirak/mode-prefix-key "C-,")
(general-create-definer akirak/bind-mode :prefix akirak/mode-prefix-key)
#+end_src
**** bind-extra-help (<f1> x) for extra help commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:42]
:END:
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-extra-help :prefix "<f1>x")
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-extra-help
    "c" #'describe-char
    "f" #'counsel-faces)
#+end_src
**** bind-specific-help (<f1> ESC) for specific help commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:43]
:END:
Also create a prefix for specific help commands, e.g. =info= and =man=:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-specific-help :prefix "<f1> ESC")
#+end_src
**** <f6> to global file commands
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-file-extra :prefix "<f6>")
#+end_src

#+begin_src emacs-lisp
  (akirak/bind-file-extra
    "M" '(nil :wk "chmod")
    "Mx" #'executable-set-magic
    "MM" #'set-file-modes)
#+end_src
**** <f7> to hydra commands
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-hydra :prefix "<f7>")
#+end_src
**** <f8> to projectile commands
#+begin_src emacs-lisp
  (general-def
    :keymaps 'projectile-mode-map
    :package 'projectile
    "<f8>" #'projectile-command-map)

  (general-create-definer akirak/bind-f8
    :package 'projectile
    :keymaps 'projectile-command-map)
#+end_src

I bind ~<f8>~ followed by another function key press to magit commands.
**** bind-system (<f12>) for system commands
:PROPERTIES:
:CREATED_TIME: [2019-04-13 Sat 09:43]
:END:
#+begin_src emacs-lisp
  (general-create-definer akirak/bind-system :prefix "<f12>"
    :prefix-map 'akirak/system-map)
#+end_src
*** Other custom key definitions
Use ~<C-return>~ for starting a REPL session:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-mode-repl
    :prefix "<C-return>")
#+end_src

Example usage:

#+begin_src emacs-lisp :tangle no
  (akirak/bind-mode-repl :keymaps '(js-mode-map typescript-mode-map)
    "" #'js-comint-repl)
#+end_src
** Dependencies for other packages
:PROPERTIES:
:TOC:      1
:CUSTOM_ID: dependencies
:ID:       ee01d40d-51af-4598-825e-dc79e4e0c394
:END:
These packages may be required by other packages loaded later on.
*** Built-in
#+begin_src emacs-lisp
(autoload 'setq-mode-local "mode-local")
#+end_src
*** dash.el
Quite a few packages depend on =dash.el= and/or =dash-functional.el=, so they should be loaded in the very beginning of package declarations.

#+begin_src emacs-lisp
  (use-package dash)
  (use-package dash-functional)
#+end_src
*** Ivy
#+begin_src emacs-lisp
  (akirak/require 'setup-ivy t)
#+end_src
*** Helm
#+begin_src emacs-lisp
  (akirak/require 'setup-helm t)
#+end_src
*** posframe
:PROPERTIES:
:CREATED_TIME: [2019-03-31 Sun 01:55]
:END:
#+begin_src emacs-lisp
  (akirak/require 'setup-posframe)
#+end_src
*** Hydra
#+begin_src emacs-lisp
  (akirak/require 'setup-hydra)
#+end_src

Bind ~M-SPC~ to =major-mode-hydra=.
This key was originally bound to =just-one-space=, but I replaced it with =akirak/shrink-whitespace=:

#+begin_src emacs-lisp
  (general-def "M-SPC" #'major-mode-hydra)

  (defconst akirak/major-mode-hydra-key "M-SPC")
#+end_src
*** frog-menu
#+begin_src emacs-lisp
  (akirak/require 'setup-frog-menu)
#+end_src
*** ov (overlays)
#+begin_src emacs-lisp
(use-package ov
  :straight (ov :host github :repo "ShingoFukuyama/ov.el"))
#+end_src
*** ts (date-time library by alphapapa)
#+begin_src emacs-lisp
  (use-package ts
    :straight (ts :host github :repo "alphapapa/ts.el"))
#+end_src
*** org-ql
#+begin_src emacs-lisp
  (use-package org-ql
    :straight (org-ql :host github :repo "alphapapa/org-ql")
    :custom
    (org-ql-views nil))
#+end_src
*** all-the-icons
#+begin_src emacs-lisp
  (use-package all-the-icons
    :general
    ("C-x 8 i" #'all-the-icons-ivy))
#+end_src
*** emacsql-sqlite
=emacsql-sqlite= depends on a pre-built binary executable. This is built and installed by Nix package manager.

#+begin_src emacs-lisp
  (use-package emacsql-sqlite
    :straight (emacsql-sqlite :type built-in)
    :if (akirak/library-exists-p "emacsql-sqlite"))
#+end_src
*** nix-env-install
#+begin_src emacs-lisp
  (use-package nix-env-install
    :straight (:host github :repo "akirak/nix-env-install"))
#+end_src
*** desktop integration
#+begin_src emacs-lisp
  (defun akirak/locate-xdg-desktop-file (desktop)
    (-some (lambda (root)
             (when (file-directory-p root)
               (car (directory-files-recursively root
                                                 (concat "^" (regexp-quote desktop) "$")
                                                 t))))
           counsel-linux-apps-directories))

  (defun akirak/get-xdg-desktop-window-class (desktop-file)
    (with-temp-buffer
      (insert-file-contents desktop-file)
      (goto-char (point-min))
      (when (re-search-forward (rx bol "StartupWmClass=") nil t)
        (buffer-substring-no-properties (point) (line-end-position)))))
#+end_src
*** language-detection
language-detection is used by eww.

#+begin_src emacs-lisp
  (akirak/require 'setup-language-detection)
#+end_src
** Platform workarounds
I use Emacs on the following platforms:

- Debian on Crostini on Chrome OS
- Ubuntu/Debian on WSL on Windows 10
*** Chrome OS support
I use Emacs on Crostini on Chrome OS, and Emacs needs some workarounds when it runs on Chrome OS:
#+begin_src emacs-lisp
  (akirak/require 'setup-chromeos t :when (akirak/running-on-crostini-p))
#+end_src
** Appearances
*** Theme
- You can set the default theme using the customization interface.
- You can override the default theme at startup with =--theme= command line option, e.g. =emacs --theme poet=.

#+begin_src emacs-lisp
  (defcustom akirak/default-theme-module 'setup-dracula-theme
    "Symbol of a module to load the default theme."
    :type '(choice (const :tag "Dracula (dark bg)" setup-dracula-theme)
                   (const :tag "Poet (light bg, especially nice for Org mode)" setup-poet-theme)
                   (const :tag "Kaolin Light (light bg)" setup-kaolin-light-theme)
                   (const :tag "Doom Solarized Light" setup-doom-solarized-light-theme)
                   (const :tag "McCarthy (light bg)" setup-mccarthy-theme))
    :group 'akirak)

  (defun akirak/set-theme-from-command-line (_arg)
    (if-let ((theme-name (pop command-line-args-left)))
        (or (akirak/require (intern (concat "setup-" theme-name "-theme")))
            (progn
              (message "%s failed to load. Fallback to the default theme.")
              (akirak/require akirak/default-theme-module)))
      (error "--theme must be followed by a theme name")))

  (add-to-list 'command-switch-alist
               '("--theme" . akirak/set-theme-from-command-line))

  ;; If the option is not given, load the default theme.
  (unless (member "--theme" (cdr command-line-args))
    (akirak/require akirak/default-theme-module))
#+end_src

*** Frame elements
Due to consistency with other applications on computer, my eyes tend to stay in the upper area of a window. I prefer relying on the header line extensively rather than the modeline.

#+begin_src emacs-lisp
  (akirak/require 'setup-header-line t)
                                          ; Hide the mode line and use the header line
  (akirak/require 'setup-feebleline t)  ; Display extra information in the echo area
  ;; (akirak/require 'setup-frame-title t)
                                          ; Configure a custom frame title format

  ;; (akirak/require 'setup-centaur-tabs)
#+end_src
*** Typeface
This modules configures extra face attributes for typography. 
This feature is enabled if and only if a window system is
available.

#+begin_src emacs-lisp
  (cond
   ((window-system)
    (akirak/require 'setup-typeface2))
   ((daemonp)
    (defun akirak/init-typeface ()
      (let ((frame (make-frame `((window-system . ,(cl-case system-type
                                                     (darwin 'ns)
                                                     (windows-nt 'w32)
                                                     (t 'x)))
                                 (visibility . nil)))))
        (unwind-protect
            (progn
              (defun akirak/ad-around-font-family-list (orig &optional _frame)
                (funcall orig frame))
              (advice-add 'font-family-list :around #'akirak/ad-around-font-family-list)
              (akirak/require 'setup-typeface2)
              (advice-remove 'font-family-list #'akirak/ad-around-font-family-list))
          (delete-frame frame))))
    (add-hook 'after-init-hook #'akirak/init-typeface)))
#+end_src

If your operating system supports Docker, you can use [[https://github.com/akirak/fonts-container][fonts-container]] to install fonts used in the module.
*** Visual enhancements
**** page-break-lines
:PROPERTIES:
:CREATED_TIME: [2019-09-24 Tue 00:49]
:END:
#+begin_src emacs-lisp
(use-package page-break-lines
  :hook ((doc-mode
          emacs-lisp-mode
          compilation-mode
          outline-mode
          prog-mode
          haskell-mode
          help-mode
          magit-mode) . page-break-lines-mode))
#+end_src
**** Color support in terminal and compilation buffers
#+begin_src emacs-lisp
  (akirak/require 'setup-terminal-colors)
  #+end_src
**** Colorize color names
#+begin_src emacs-lisp
(use-package rainbow-mode
  ;; :diminish 'rainbow-mode
  :commands (rainbow-mode)
  :hook
  (prog-mode . (lambda () (rainbow-mode 1))))
#+end_src
**** fontify-face
#+begin_src emacs-lisp
(use-package fontify-face
  :hook
  (emacs-lisp . (lambda () (fontify-face-mode 1))))
#+end_src
**** Centralizing window contents
#+begin_src emacs-lisp
  (akirak/require 'setup-perfect-margin)
  #+end_src

I'm not using olivetti-mode

#+begin_src emacs-lisp
(use-package olivetti
  :disabled t
  :commands (turn-on-olivetti-mode)
  :custom (olivetti-body-width 92))
#+end_src
** A bunch of useful features
:PROPERTIES:
:TOC:      1
:ID:       7042f1a9-0cd3-4769-acda-a98d200f569b
:CUSTOM_ID: enhancements
:END:
#+begin_src emacs-lisp
  ;; desktop needs to be configured in prior to other convenience packages
  (akirak/require 'setup-desktop)
  (akirak/require 'setup-meta)
  (akirak/require 'setup-misc)
#+end_src

*** Pretty hydras
#+begin_src emacs-lisp
  ;; C-c h
  (akirak/bind-user "h" #'akirak/minor-mode-hydra/body)
  (general-def "C-z" #'akirak/context-hydra/body)
  (general-def [remap text-scale-adjust] 'akirak/appearance-hydra/body)
  (akirak/bind-user "k" #'akirak/window-layout-hydra/body)
  (general-def "<f1>j" #'akirak/emacs-lisp-debugging-hydra/body)
#+end_src
**** Context hydra
:PROPERTIES:
:CREATED_TIME: [2019-07-27 Sat 17:43]
:END:
The following hydra is deprecated:

#+begin_src emacs-lisp
  (pretty-hydra-define akirak/context-hydra
    (:title (string-join
             `(,(concat "Desktop dir: "
                        (or (ignore-errors
                              (and desktop-dirname
                                   (format "%s %s"
                                           (abbreviate-file-name desktop-dirname)
                                           (if (file-exists-p (desktop-full-file-name))
                                               (format "(exists, updated: %s)"
                                                       (akirak/context-hydra-format-relative-filetime
                                                        (desktop-full-file-name) t))
                                             "(does not exist)"))))
                            "nil"))
               ,(concat " Current clock: "
                        (or (ignore-errors
                              (and (markerp org-clock-marker)
                                   (with-current-buffer (marker-buffer org-clock-marker)
                                     (concat (buffer-name)
                                             ": "
                                             (org-with-wide-buffer
                                              (goto-char (marker-position org-clock-marker))
                                              (substring-no-properties
                                               (org-format-outline-path
                                                (org-get-outline-path t t))))))))
                            "nil")))
             "\n")
            :quit-key "C-g"
            :foreign-keys run)
    ("Org"
     (("j" org-clock-goto "Go to clock" :exit t)
      ("h" counsel-org-clock-history "History" :exit t)
      ("a" org-agenda "Agenda" :exit t)
      ("O" org-clock-out "Clock out")
      ("C-q" org-clock-cancel "Cancel clock"))
     "Desktop"
     (("s" desktop-save-in-desktop-dir "Save to the dir")
      ("w" desktop-save "Save to another dir")
      ("R" desktop-read "Reload from the dir")
      ("D" desktop-remove "Purge")
      ("L" desktop-change-dir "Change the dir")
      ("F" desktop-clear "Clear"))
     "Projectile & Magit"
     (("p" projectile-switch-project "Switch project" :exit t)
      ("g" magit-list-repositories "Git repo list" :exit t))
     "Lock"
     (("o" org-offtime-ivy "Offtime"))))

  (defun akirak/context-hydra-format-relative-filetime (file &optional verbose type)
    (let* ((attrs (file-attributes file))
           (internal (pcase type
                       ;; TODO: Add support for other time attributes, e.g. visited time
                       (_ (file-attribute-modification-time attrs))))
           (file-time (make-ts :unix (float-time internal)))
           (abs-format "%Y-%m-%d %H:%M"))
      (if verbose
          (format "%s (%s)"
                  (ts-format abs-format file-time)
                  (ts-human-format-duration
                   (ts-difference (ts-now) file-time)
                   'abbreviate))
        (ts-format abs-format file-time))))
#+end_src

Instead, I will bind ~<f10>~ to a context-sensitive command:

#+begin_src emacs-lisp
  (defun akirak/contextual-f10 ()
    (interactive)
    (cond
     ((org-clocking-p)
      (message "This command currently does nothing when you are clocking in"))
     (t
      (call-interactively 'org-agenda))))

  (general-def "<f10>" #'akirak/contextual-f10)
#+end_src
**** Minor-mode-hydra: hydra for toggling minor modes
#+begin_src emacs-lisp
  (pretty-hydra-define akirak/minor-mode-hydra
    (:title "Minor modes"
            :foreign-keys nil
            :quit-key "q")
    ("Focus"
     (("v" view-mode :toggle t))
     "Info/check/linting"
     (("ed" eldoc-mode :toggle t)
      ("fc" flycheck-mode :toggle t)
      ("fv" flycheck-verify-setup)
      ("fs" flyspell-mode :toggle t)
      ("fp" flyspell-prog-mode :toggle t)
      ("a" apheleia-mode :toggle t)
      ("A" apheleia-global-mode :toggle t)
      ("ld" lsp-ui-doc-mode :toggle t)
      ("lp" lsp-ui-peek-mode :toggle t)
      ("ls" lsp-ui-sideline-mode :toggle t))
     "Edit/assistance"
     (("s" smartparens-mode :toggle t)
      ("S" smartparens-strict-mode :toggle t)
      ("y" lispy-mode :toggle t)
      ("el" electric-layout-mode :toggle t)
      ("ei" electric-indent-local-mode :toggle t)
      ("eq" electric-quote-local-mode :toggle t)
      ("ea" aggressive-indent-mode :toggle t)
      ("o" origami-mode :toggle t)
      ("W" whitespace-cleanup-mode))
     "Visual"
     (("w" whitespace-mode :toggle t)
      ("r" rainbow-delimiters-mode :toggle t)
      ("p" page-break-lines-mode :toggle t)
      ("n" line-number-mode :toggle t)
      ("hi" highlight-indent-guides-mode :toggle t)
      ("hc" fci-mode :toggle t))
     "LSP"
     (("lh" lsp-describe-session)
      ("lR" lsp-restart-workspace)
      ("lS" lsp-shutdown-workspace))))
#+end_src
**** Hydra for changing the appearance
:PROPERTIES:
:CREATED_TIME: [2019-07-27 Sat 22:11]
:END:
#+begin_src emacs-lisp
  (pretty-hydra-define akirak/appearance-hydra
    (:title (format "Font height: %d" akirak/font-height)
            :quit-key "q")
    ("Default font height"
     (("=" akirak/font-height-increase "increase")
      ("-" akirak/font-height-decrease "decrease")
      ("s" akirak/set-font-height "set temporarily")
      ("C-s" (customize-save-variable 'akirak/font-height akirak/font-height)
       "save"))
     "Buffer font height"
     (("+" text-scale-increase "increase")
      ("_" text-scale-decrease "decrease")
      ("!" text-scale-set "default"))
     ;; TODO: Add commands to change the theme and font families
     ;; "Faces"
     ;; (("t" akirak/load-theme-package "Change theme")
     ;;  ("f" akirak/configure-font-families "Font families"))
     "Inspect"
     (("c" describe-char))))
#+end_src
**** Hydra for managing window layouts
:PROPERTIES:
:CREATED_TIME: [2019-09-20 Fri 12:47]
:END:
#+begin_src emacs-lisp
  (pretty-hydra-define akirak/window-layout-hydra
    (:title (format "Layout\n Window size %sx%s"
                    (window-width)
                    (window-height))
            :quit-key "q")
    ("Window size"
     (("w" enlarge-window-horizontally "width+")
      ("W" shrink-window-horizontally "width-")
      ("h" enlarge-window "height+")
      ("H" shrink-window "height-")
      ("ah" (set-window-text-height (selected-window) current-prefix-arg) "abs h"))
     "Layout"
     (("b" balance-windows "Balance frm")
      ("B" (balance-windows (selected-window)) "Balance win")
      ("s" split-window-below "Split below")
      ("v" split-window-right "Split right")
      ("d" delete-window "Delete win"))
     "Switch win/buf"
     (("j" other-window "Next win")
      ("k" (other-window -1) "Prev win")
      ("l" counsel-ibuffer "Switch buf"))
     "Extra windows"
     (("tt" treemacs)
      ("te" akirak/toggle-flycheck-error-list "flycheck")
      ("ti" imenu-list-smart-toggle "imenu")
      ("tb" ibuffer-sidebar "buffers"))
     "Views"
     (("pv" ivy-pop-view "pop")
      ("pV" ivy-push-view "push")
      ("ps" ivy-switch-view "switch"))))

  (defun akirak/toggle-flycheck-error-list ()
    (interactive)
    (if-let ((window (get-buffer-window "*Flycheck errors*")))
        (quit-window nil window)
      (flycheck-list-errors)))
#+end_src
**** Emacs debugging hydra
:PROPERTIES:
:CREATED_TIME: [2019-07-27 Sat 17:43]
:END:
#+begin_src emacs-lisp
  (pretty-hydra-define akirak/emacs-lisp-debugging-hydra
    (:title "Emacs Lisp Debugging")
    ("Debug"
     (("d" toggle-debug-on-error :toggle (default-value 'debug-on-error)))
     "Profiler"
     (("s" profiler-start "Start" :exit t)
      ("S" (progn
             (profiler-report)
             (profiler-stop)) "Report" :exit t)
      ("R" profiler-reset "Reset"))))
#+end_src
*** frame-workflow
[[https://github.com/akirak/frame-workflow][frame-workflow]] is my package originally written for providing named workspaces in EXWM. 

#+begin_src emacs-lisp
  (akirak/require 'setup-frame-workflow t) ; Ensure loading frame-workflow

  (general-def "C-M-g" #'frame-workflow-prefix-map)
#+end_src

*** Terminal and shells
#+begin_src emacs-lisp
  (akirak/require 'setup-terminal t)
#+end_src
**** Using vterm
I will use vterm.

#+begin_src emacs-lisp
  (akirak/require 'setup-vterm)
#+end_src

To open a terminal, use =vterm-toggle=. =vterm-toggle-cd= command supports tramp.

#+begin_src emacs-lisp
  (akirak/bind-user "t" #'vterm-toggle-cd)
#+end_src
**** Frame
#+begin_src emacs-lisp
  (defun akirak/vterm-buffer-live-p ()
    (and (derived-mode-p 'vterm-mode)
         (let ((process (get-buffer-process (current-buffer))))
           (and process
                (process-live-p process)))))

  (defun akirak/get-live-vterm-buffer ()
    (car (-filter (lambda (buf)
                    (with-current-buffer buf
                      (akirak/vterm-buffer-live-p)))
                  (buffer-list))))

  (defun akirak/get-or-create-vterm-buffer ()
    (or (akirak/vterm-buffer-live-p)
        (akirak/get-live-vterm-buffer)
        (progn
          (vterm)
          (current-buffer))))

  (frame-workflow-define-subject "terminal"
    :key "t"
    :make-frame
    '(let ((frame-purpose--initial-buffer-fn #'akirak/get-or-create-vterm-buffer))
       (frame-purpose-make-frame :modes '(term-mode
                                          vterm-mode
                                          eshell-mode
                                          shell-mode)))
    :layout
    '(switch-to-buffer (akirak/get-or-create-vterm-buffer))
    :refocus
    '(switch-to-buffer (akirak/get-or-create-vterm-buffer)))
#+end_src

*** Dired
#+begin_src emacs-lisp
  (general-def "C-x C-j" #'dired-jump)
#+end_src
**** Hydra
#+begin_src emacs-lisp
  (major-mode-hydra-define dired-mode
    (:title "Dired")
    ("Open/execute"
     (("x" dired-open-xdg))
     "Transfer"
     (("r" dired-rsync))))
#+end_src
**** Frame
#+begin_src emacs-lisp
  (akirak/define-frame-workflow "dired"
    :key "d"
    :make-frame
    '(frame-purpose-make-mode-frame 'dired-mode)
    :layout
    '(when (fboundp 'ibuffer-sidebar-show-sidebar)
       (ibuffer-sidebar-show-sidebar)))
#+end_src

*** Crux and file operations
#+begin_src emacs-lisp
  (general-def
    "C-x D" #'crux-delete-file-and-buffer
    "C-x R" #'crux-rename-file-and-buffer
    "C-x S" #'sudo-find-file
    "C-x x" #'crux-open-with)
#+end_src

#+begin_src emacs-lisp
  (akirak/require 'setup-files)
#+end_src
*** Buffer management
#+begin_src emacs-lisp
  ;; buffer management
  (general-def
    "<f5>" 'revert-buffer
    "C-x k" #'kill-this-buffer  
    "C-x C-b" #'ibuffer)
#+end_src
*** Git
**** Git modes
#+begin_src emacs-lisp
(use-package git-modes)
#+end_src
**** Git attr linguist
#+begin_src emacs-lisp
(use-package git-attr-linguist
  :straight git-attr
  :commands (git-attr-linguist)
  :hook (find-file . git-attr-linguist))
#+end_src
**** magit-todos
#+begin_src emacs-lisp
  (use-package magit-todos :after (magit hl-todo)
    :straight (magit-todos :host github :repo "alphapapa/magit-todos")
    :config
    (magit-todos-mode 1)
    :custom
    (magit-todos-exclude-globs '("**/*.map")))
#+end_src
**** GitHub/GitLab workflow
Create a prefix key for =browse-at-remote=-variant commands:

#+begin_src emacs-lisp
  (general-create-definer akirak/bind-browse-at-remote :prefix "C-x w"
    :wk "browse-at-remote")
#+end_src

Use =forge= for working with GitHub and GitLab repositories:

#+begin_src emacs-lisp
  (akirak/require 'setup-github)
#+end_src

To create/fork a repository on GitHub, use =hub= CLI.

=github-review.el= looks useful for reviewing pull requests on GitHub, but I seldom receive pull requests, so I have never used it.
***** Browse-at-remote
=browse-at-remote= is another package that lets you browse a corresponding web page of the file.

#+begin_src emacs-lisp
  (use-package browse-at-remote
    :commands (browse-at-remote))

  (akirak/bind-browse-at-remote
    "l" #'browse-at-remote
    "k" #'browse-at-remote-kill)
#+end_src

Differences between =browse-at-remote= and equivalent commands from =forge= package:

- =browse-at-remote= provides =browse-at-remote-kill= command.
- =browse-at-remote= opens a link with a line number.
**** Cloning Git repositories
[[file:setup/setup-git-clone.el::(defun%20akirak/git-clone%20(url)][akirak/git-clone]] function lets you clone a Git repository to a designated location from a Git repository, a GitHub repository page, or a path on GitHub (=account/name=). It is integrated with ivy-clipurl, so you can clone a Git repository from its web page URL in the clipboard.
**** magit-list-repositories
=magit-list-repositories= is a convenient command which lets you browse your repositories on the file system.

To use it, you first have to customize =magit-repository-directories=.
**** Git-Annex
Use =magit-annex= for working with =git-annex= repositories:

#+begin_src emacs-lisp
  (akirak/require 'setup-git-annex)
#+end_src
*** Project management
**** Projectile
**** EditorConfig
#+begin_src emacs-lisp
(use-package editorconfig
  :config
  (editorconfig-mode 1))
#+end_src
**** DirEnv
#+begin_src emacs-lisp
  (akirak/require 'setup-direnv)
  #+end_src
*** Web browser integration
#+begin_src emacs-lisp
  (akirak/require 'setup-web-browser)
#+end_src

#+begin_src emacs-lisp
(use-package atomic-chrome
  :disabled t
  :init
  (atomic-chrome-start-server))
#+end_src

Emacs also provides eww:

#+begin_src emacs-lisp
  (akirak/require 'setup-eww)
#+end_src
*** Company completion
#+begin_src emacs-lisp
(general-def :package 'company :keymaps 'company-mode-map
  "M-/" #'company-complete)
#+end_src
*** Templates
#+begin_src emacs-lisp
  (akirak/require 'setup-expansion)
#+end_src

**** Yasnippet and auto-yasnippet
:PROPERTIES:
:CREATED_TIME: [2019-09-24 Tue 00:45]
:END:
I prefer using =ivy-yasnippet= for choosing a snippet:

#+begin_src emacs-lisp
  (akirak/bind-user "y" 'ivy-yasnippet)
  (akirak/bind-register "M-n" 'yas-new-snippet)
#+end_src

=auto-yasnippet= is convenient for temporary snippets:

#+begin_src emacs-lisp
  (akirak/bind-register-map
    "a" 'aya-create
    "e" 'aya-expand)
#+end_src

=aya-open-line= is the fastest way to expand a snippet if you know its name. It behaves like =open-line= if the word before the point is not registered as a snippet:

#+begin_src emacs-lisp
  (general-def "C-o" 'aya-open-line)
#+end_src
**** Yankpad
:PROPERTIES:
:CREATED_TIME: [2019-09-24 Tue 00:45]
:END:
Yankpad is more useful in writing.

#+begin_src emacs-lisp
  (akirak/bind-user "p" #'yankpad-insert)
  (akirak/bind-generic "y" #'yankpad-map)
#+end_src
**** File templates
#+begin_src emacs-lisp
  (akirak/require 'setup-autoinsert)
  #+end_src
**** Emmet
:PROPERTIES:
:CREATED_TIME: [2019-11-24 Sun 02:23]
:END:
Use emmet for producing HTML tags.
*** Frequent counsel commands                                  :navigation:
#+begin_src emacs-lisp
  (general-def
    "C-x p" #'counsel-projectile
    "C-x /" #'counsel-rg
    "C-x F" #'counsel-recentf
    "C-x L" #'counsel-locate)
#+end_src
*** Avy                                                        :navigation:
#+begin_src emacs-lisp
  (akirak/require 'setup-avy)

  (akirak/bind-key "C-'" 'avy-goto-char-timer)

  (general-unbind "C-'" :keymaps 'org-mode-map :package 'org)
#+end_src

=link-hint= is not part of =avy= package, but it is covenient for following a link:

#+begin_src emacs-lisp
  (akirak/bind-jump "f" 'akirak/link-hint-open-link)
#+end_src
*** Source code navigation                                     :navigation:
**** dumb-jump
:PROPERTIES:
:CREATED_TIME: [2019-09-24 Tue 00:30]
:END:
#+begin_src emacs-lisp
  (use-package dumb-jump
    ;; Don't enable dumb-jump-mode. Bind only necessary commands.
    :custom
    (dumb-jump-selector 'ivy))

  (akirak/bind-jump
    ". " #'dumb-jump-go
    "," #'dumb-jump-back)
#+end_src
**** IMenu
:PROPERTIES:
:CREATED_TIME: [2019-09-24 Tue 00:30]
:END:
#+begin_src emacs-lisp
  (akirak/bind-search "i" 'counsel-imenu)

  (akirak/bind-search :package 'org :keymaps 'org-mode-map
    "i" 'counsel-org-goto)
#+end_src

=imenu-list= is a useful package which displays an overview of the current buffer.
I've added it to =akirak/window-layout-hydra=.

#+begin_src emacs-lisp
  (akirak/require 'setup-imenu-list)
  #+end_src
**** Outline navigation                                       :navigation:
#+begin_src emacs-lisp
  (akirak/bind-search "o" 'counsel-outline)
  (akirak/bind-search :package 'org :keymaps 'org-mode-map
    "o" 'counsel-org-goto)
#+end_src
*** Outline editing                                              :outlines:
#+begin_src emacs-lisp
  (general-def :keymaps 'outline-minor-mode-map :package 'outshine
    "M-RET" 'outshine-insert-heading)
  (general-unbind :keymaps 'lispy-mode-map :package 'lispy "M-RET")
#+end_src

#+begin_src emacs-lisp
  (akirak/require 'setup-origami)
#+end_src
*** Referencing                                               :referencing:
#+begin_src emacs-lisp
(akirak/require 'setup-referencing)
#+end_src

**** PDF
Use =pdf-tools=.

=pdf-tools= is installed using Nix.
**** EPUB
#+begin_src emacs-lisp
  (akirak/require 'setup-epub)
#+end_src
**** Annotating documents
You can use org-noter to annotate PDF documents as well as other formats supported by doc-view.

I will bind ~A~ to =org-noter= both in =pdf-tools= and =doc-view=:

#+begin_src emacs-lisp
  (general-def :keymaps 'doc-view-mode-map :package 'doc-view
    "A" #'org-noter)

  (general-def :keymaps 'pdf-view-mode-map :package 'pdf-view
    "A" #'org-noter)
#+end_src
**** Finding documentation
***** Built-in help system
#+begin_src emacs-lisp
  (akirak/bind-specific-help
    "i" #'helm-info
    "m" #'woman)
#+end_src

I often consult the Emacs Lisp manual:

#+begin_src emacs-lisp
  (defun akirak/info-elisp ()
    (interactive)
    (info "elisp")
    (call-interactively 'Info-menu))

  (akirak/bind-help
    "e" #'akirak/info-elisp)
#+end_src
***** DevDocs
#+begin_src emacs-lisp
  (use-package devdocs-lookup
    :straight (devdocs-lookup :host github :repo "skeeto/devdocs-lookup")
    :commands (devdocs-lookup))

  (akirak/bind-user "d" #'devdocs-lookup)
#+end_src
***** Dash
#+begin_src emacs-lisp
  (use-package dash-docs)

  (use-package helm-dash
    :custom
    (helm-dash-browser-func #'akirak/read-local-html-as-org))

  (akirak/bind-specific-help
    "d" #'helm-dash)

  ;; "a" #'helm-dash-activate-docset
  ;; "d" #'helm-dash-at-point
  ;; "+" #'helm-dash-install-docset
#+end_src
*** General tools for editing source code
:PROPERTIES:
:CREATED_TIME: [2019-06-11 Tue 22:30]
:END:
**** Expand Region
#+begin_src emacs-lisp
  (akirak/require 'setup-expand-region)
#+end_src
**** Formatting
:PROPERTIES:
:CREATED_TIME: [2019-09-23 Mon 22:48]
:END:
I will try out apheleia.

#+begin_src emacs-lisp
  (akirak/require 'setup-apheleia)
#+end_src

Another option would be reformatter by Steve Purcell, but I haven't managed to configure it for Nix + npm projects yet.

#+begin_src emacs-lisp
  ;; (akirak/require 'setup-reformatter)
#+end_src
**** Commenting
#+begin_src emacs-lisp
(use-package comment-dwim-2
  :general
  ("M-;" 'comment-dwim-2))
#+end_src
**** Refactoring
#+begin_src emacs-lisp
  (akirak/require 'setup-refactor)
#+end_src
**** Case conversion
#+begin_src emacs-lisp
(use-package fix-word
  :commands (fix-word-upcase fix-word-downcase fix-word-capitalize)
  :hook
  (prog-mode . (lambda () (setq fix-word-thing 'symbol)))
  :general
  ([remap upcase-word] 'fix-word-upcase
   [remap downcase-word] 'fix-word-downcase
   [remap capitalize-word] 'fix-word-capitalize))
#+end_src

#+begin_src emacs-lisp
  (akirak/require 'setup-string-inflection)
  #+end_src
**** Highlighting todos via hl-todo
Use hl-todo by tarsius

#+begin_src emacs-lisp
  (use-package hl-todo
    :config
    (akirak/bind-jump :keymaps 'hl-todo-mode-map "t" #'hl-todo-next)
    (akirak/bind-insert :keymaps 'hl-todo-mode-map "t" #'hl-todo-insert)
    :hook (prog-mode . hl-todo-mode))
#+end_src

There is another package named comment-tags for the same purpose, but I won't use it since there is hl-todo

#+begin_src emacs-lisp
  (use-package comment-tags
    :disabled t
    :config
    (akirak/bind-generic :keymaps 'comment-tags-mode-map
      "'" (defrepeater 'comment-tags-next-tag))
    :hook (prog-mode . comment-tags-mode)
    :custom
    (comment-tags-case-sensitive t)
    (comment-tags-comment-start-only t))
#+end_src
*** Editing specific types of formats
:PROPERTIES:
:CREATED_TIME: [2019-06-11 Tue 22:27]
:END:
#+begin_src emacs-lisp
  (akirak/require 'setup-tagedit)
#+end_src
*** Miscellaneous commands
**** Switching to an Org window
#+begin_src emacs-lisp
  (defvar org-select-window-last-window nil)

  (defun org-select-window (arg)
    (interactive "P")
    (if arg
        (progn
          (when org-select-window-last-window
            (select-window org-select-window-last-window)
            (setq org-select-window-last-window nil)))
      (let* ((wlist (window-list))
             (i0 (-elem-index (selected-window) wlist))
             (queue (append (-slice wlist (1+ i0))
                            (-take i0 wlist)))
             (w (-find (lambda (w)
                         (with-current-buffer (window-buffer w)
                           (derived-mode-p 'org-mode)))
                       queue)))
        (if w
            (progn
              (unless (derived-mode-p 'org-mode)
                (setq org-select-window-last-window (selected-window)))
              (select-window w))
          (message "No other org window in this frame")))))
#+end_src
**** modi/org-split-block
#+begin_src emacs-lisp
  (use-package modi-org-split-block
    :straight nil
    :load-path "contrib/modi")
  (akirak/bind-key :package 'org :keymaps 'org-mode-map
    [remap org-meta-return] 'modi/org-meta-return)
#+end_src
*** Poporg
:PROPERTIES:
:CREATED_TIME: [2018-12-29 Sat 19:51]
:ID:       e76069bd-d9b2-488a-a5c8-9f2410240396
:END:

Use poporg rather than outorg.

- [X] Add poporg package
- [X] Remap keys

#+begin_src emacs-lisp
  ;; (akirak/require 'setup-poporg)
#+end_src
*** Window management
:PROPERTIES:
:CREATED_TIME: [2018-12-31 Mon 05:04]
:END:
#+begin_src emacs-lisp
(akirak/bind-user
  "u" #'winner-undo-repeat)
#+end_src

I created a hydra for managing frames and windows.

#+begin_src emacs-lisp
  (akirak/bind-key "M-o" #'ace-window)
  ;; You can also display the help from the start
  ;; (akirak/bind-key "M-o" #'aw-show-dispatch-help)
  (general-unbind :keymaps 'lispy-mode-map :package 'lispy "M-o")
#+end_src
**** Other packages for window management
#+begin_src emacs-lisp
(use-package fwb-cmds
  :straight (fwb-cmds :host github :repo "tarsius/fwb-cmds"))
(use-package buffer-move
  :commands (buf-move-up buf-move-down buf-move-left buf-move-right))
(use-package window-go
  :straight (window-go :host github :repo "akirak/emacs-window-go"))
#+end_src
*** Visual cues and extra information display

Additional visual cues can increase productivity, but they can be noisy at the same time. Therefore I need to justify each package added to my config.

**** Beacon
I often lose sight of the cursor when I switch to another window, so this is necessary.
#+begin_src emacs-lisp
  (use-package beacon                     ; Highlight the cursor on certain events
    :config
    (beacon-mode 1))
#+end_src
**** Rainbow-delimiters
This is especially useful in editing Lisp code.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters         ; Colourize parentheses in source code
    :hook
    ((lisp-mode
      elixir-mode
      haskell-mode
      ) . rainbow-delimiters-mode))
#+end_src
**** Dimmer
This package makes the focused window stands out by dimming the other windows. However, the dimness should be kept small to make referenced text readable.
#+begin_src emacs-lisp
  (akirak/require 'setup-dimmer)
#+end_src
**** Git-gutter
This lets you know which parts of the buffers are modified since the last commit.
#+begin_src emacs-lisp
  (use-package git-gutter
    :diminish git-gutter-mode
    :init
    (global-git-gutter-mode))

  ;; NOTE: There is no git-gutter-mode-map
  (akirak/bind-jump
    "j" 'git-gutter:next-hunk
    "k" 'git-gutter:previous-hunk)
#+end_src
**** Highlight-indent-guides
This is helpful in programming languages that depend on indentation levels.
#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :hook
    ((python-mode nim-mode) . highlight-indent-guides-mode))
#+end_src
**** Prism
#+begin_src emacs-lisp
  (akirak/require 'setup-prism)
#+end_src
**** Column-enforce-mode
#+begin_src emacs-lisp
  (use-package column-enforce-mode
    :disabled t
    :hook
    ((prog-mode markdown-mode)
     . 80-column-rule))
#+end_src
**** Fill-column-indicator
Visualise (usually) 80 columns.
#+begin_src emacs-lisp
  (use-package fill-column-indicator
    :init
    (add-hook 'prog-mode-hook 'fci-mode))
#+end_src
**** Whitespace
Visualise unnecessary, extra whitespace characters in source code.

#+begin_src emacs-lisp
  (akirak/require 'setup-whitespace)
  #+end_src
**** Manual highlighting
***** Symbol overlays
#+begin_src emacs-lisp
(use-package symbol-overlay
  :commands (symbol-overlay-put symbol-overlay-mode))
#+end_src
***** Visual bookmarks
#+begin_src emacs-lisp
  (akirak/require 'setup-bm)
  #+end_src
*** Startup buffer
By default, =*Messages*= buffer is shown at startup.

#+begin_src emacs-lisp
  (akirak/require 'setup-initial-buffer)
#+end_src

*** Auto saving and auto git-commit

Files are automatically saved on certain events by =super-save-mode=:

#+begin_src emacs-lisp
  (akirak/require 'setup-super-save)
#+end_src

Some files are automatically committed to their contained repositories.

[[file:setup/setup-git-auto-commit.el]]
*** org-web-tools and clipurl
[[https://github.com/alphapapa/org-web-tools][org-web-tools]] is handy, but commands in the package often fail to retrieve a proper URL I want to operate on. Therefore I created =clipurl= package to pick a URL from the kill ring.

#+begin_src emacs-lisp
  (akirak/require 'setup-org-web-tools)

  (defun akirak/insert-previous-url-link ()
    (interactive)
    (if current-prefix-arg
	(call-interactively 'ivy-clipurl)
      ;; Use ivy-clipurl in place of org-web-tools-insert-link.
      (let ((ivy-clipurl-default-action 'clipurl-insert-url-dwim)
	    (ivy-clipurl-prompt "Choose a URL to insert: "))
	(call-interactively 'ivy-clipurl))
      ;; (call-interactively 'org-web-tools-insert-link-for-url)
      ))

  (akirak/bind-user "w" 'akirak/insert-previous-url-link)
#+end_src

To visit a URL, use =browse-url-at-point=:

#+begin_src emacs-lisp
  (akirak/bind-user "o" #'browse-url-at-point)
#+end_src

*** Highlighting part(s) of source code and focusing
:PROPERTIES:
:CREATED_TIME: [2019-01-25 Fri 22:47]
:END:

- bm (visual bookmarks)
- symbol-overlay

#+begin_src emacs-lisp
(akirak/bind-user
  "b" 'helm-bm
  "m" 'bm-toggle
  "s" 'symbol-overlay-put)
#+end_src

#+begin_src emacs-lisp
  (general-def
    "C-x n" #'akirak/narrow-or-widen-dwim)

  (general-def :keymaps 'org-mode-map
    "C-x n" #'akirak/narrow-or-widen-dwim)
#+end_src

*** Development workflow
#+begin_src emacs-lisp
  (general-def
    "<f9>" 'recompile)

  (general-def
    "C-x t" #'helm-tail)
#+end_src
*** Scratch buffers
#+begin_src emacs-lisp
;; Development
(akirak/bind-user
  "i" 'scratch)
#+end_src
*** Spell checking and iedit                               :editor:writing:
Note that iedit works with [[file:setup/setup-multiple-cursors.el][multiple-cursors]]. You can first select all the occurrences of a symbol using multiple-cursors and then edit them using iedit.

#+begin_src emacs-lisp
  (general-def "C-;" 'akirak/iedit-or-flyspell)

  (defun akirak/iedit-or-flyspell ()
    "With a prefix argument, run iedit in the function. Otherwise, run iedit or flyspell.

  With a prefix argument, call `unpackaged/iedit-scoped'.
  Otherwise, call `unpackaged/iedit-or-flyspell'."
    (interactive)
    (if current-prefix-arg
	(unpackaged/iedit-scoped)
      (unpackaged/iedit-or-flyspell)))

  (defhydra akirak/flyspell-hydra ()
    "flyspell"
    ("n" flyspell-goto-next-error)
    ("c" flyspell-correct-word))

  (defun akirak/turn-on-flyspell-mode-in-text-mode ()
    (when (derived-mode-p 'text-mode)
      (flyspell-mode-on)))

  (advice-add 'akirak/flyspell-hydra/body
              :before 'akirak/turn-on-flyspell-mode-in-text-mode)
#+end_src
*** Integrating language servers
#+begin_src emacs-lisp
  (akirak/require 'setup-bold)
#+end_src
*** Optimization
#+begin_src emacs-lisp
  (akirak/require 'optimize-minibuf)
#+end_src
**** Startup
Use =benchmark-init= for profiling of the startup time.

#+begin_src emacs-lisp
(akirak/require 'setup-init-time-log)
#+end_src
** Writing
:PROPERTIES:
:TOC:      1
:END:
*** Multi-lingual support
:PROPERTIES:
:CREATED_TIME: [2019-03-23 Sat 16:36]
:END:

A modules for supporting a natural language should follow the naming convention of =setup-LANGUAGE-SYSTEM=. For example, =setup-chinese-pyim= is a Chinese support through =pyim.el=.

You can customize a list of modules for supported languages through the following variable. This setting can be done per machine, so different machines can support different languages:

#+begin_src emacs-lisp
  (defcustom akirak/enabled-language-supports
    nil
    "List of enabled modules for supporting natural languages other than English.

  These modules are loaded at startup.

  I also suggest you set `default-input-method' to your preferred
  input method in the environment."
    :group 'akirak
    :type '(set (const :tag "Japanese/ (mozc)" setup-japanese-mozc)
                (const :tag "Chinese/ (pyim)" setup-chinese-pyim))
    :set (lambda (sym value)
           (set sym value)
           (dolist (module value)
             (akirak/require module))
           (when (= 1 (length value))
             (setq default-input-method
                   (string-remove-prefix "setup-" (symbol-name (car value)))))))
#+end_src

I don't set the default input method here. Set =default-input-method= in your =custom-file=. 
**** Google Translate
#+begin_src emacs-lisp
  (akirak/require 'setup-google-translate)
#+end_src
*** Utilities
#+begin_src emacs-lisp
  (akirak/require 'setup-writing)
#+end_src
**** Spell checking with flyspell
I will use [[https://github.com/d12frosted/flyspell-correct][flyspell-correct]] to run flyspell.

- =flyspell-correct-wrapper= is the main entry point to the package.
  I bind ~C-c f~ to the command.
  - When =flyspell-mode= is not on, the key sequence turns the mode on.

#+begin_src emacs-lisp
  (akirak/bind-user
    "f" #'flyspell-spell-mode)

  (akirak/bind-user :keymaps 'flyspell-mode-map
    "f" #'flyspell-correct-wrapper)
#+end_src
**** Quotation marks
***** Typo
Typo.el is a successor to [[https://www.emacswiki.org/emacs/TypographicalPunctuationMarks][typopunct.el]].

Note it doesnt support CJK languages.
It can be useful for European languages.
**** Counting words
Use =wc-mode= or =org-wc= for counting words.
**** WriteGood mode
- [[http://bnbeckwith.com/code/writegood-mode.html][WriteGood Mode]]
- [[http://matt.might.net/articles/shell-scripts-for-passive-voice-weasel-words-duplicates/][3 shell scripts: Kill weasel words, avoid the passive, eliminate duplicates]]
*** Using Org mode
Set basic options for org-mode:

#+begin_src emacs-lisp
  (akirak/require 'setup-org t)
  ;; Use org-edna for dependency management
  (akirak/require 'setup-org-edna)

  ;; org-starter should be loaded after org is loaded
  (akirak/require 'setup-org-starter)
#+end_src
**** org-plain-wiki
Use org-plain-wiki experimentally.

#+begin_src emacs-lisp
  (akirak/require 'setup-org-wiki)
#+end_src
**** Org hydra
Use major-mode-hydra to define a hydra for Org mode:

#+begin_src emacs-lisp
  (akirak/require 'setup-org-hydra)
#+end_src
**** Org-babel
- Graphviz (=graphviz-dot-mode=)
- Ditaa

#+begin_src emacs-lisp
  (akirak/require 'setup-org-babel t)
#+end_src
**** Exporting
- Exporting to Hugo

#+begin_src emacs-lisp
  (akirak/require 'setup-ox)
  (akirak/require 'setup-org-hugo)
#+end_src
*** Markdown
Markdown is supported as well:

#+begin_src emacs-lisp
  (akirak/require 'setup-markdown)
#+end_src
** Programming languages
:PROPERTIES:
:TOC:      1
:sort:     a
:END:
Ideally, this section should be a portfolio of my skills.
*** Elixir

#+begin_src emacs-lisp
  (akirak/require 'setup-elixir)
#+end_src

*** Elm

#+begin_src emacs-lisp
  (akirak/require 'setup-elm)
#+end_src

*** Emacs Lisp
#+begin_src emacs-lisp
(akirak/require 'setup-emacs-lisp)
#+end_src
**** Hydra
#+begin_src emacs-lisp
  (major-mode-hydra-define emacs-lisp-mode
    (:title "emacs-lisp-mode"
            :quit-key "q")
    ("file/buffer"
     (("e" akirak/eval-buffer-or-load-file "Eval or load file")
      ("l" package-lint-current-buffer "package-lint"))
     "point"
     (("m" pp-macroexpand-last-sexp "macroexpand"))
     "help/references"
     (("s" suggest)
      ("i" counsel-info-lookup-symbol "info symbol"))))
#+end_src
**** Frame
#+begin_src emacs-lisp
  (akirak/define-frame-workflow "emacs-lisp"
    :key "e"
    :make-frame '(frame-purpose-make-mode-frame 'emacs-lisp-mode))
#+end_src
**** Frame for the Emacs config
#+begin_src emacs-lisp
  (akirak/define-frame-workflow "emacs-config"
    :key "C"
    :layout
    '(progn
       (delete-other-windows)
       (let ((default-directory user-emacs-directory))
         (frame-workflow-magit-same-window)))
    :make-frame
    '(frame-purpose-make-directory-frame user-emacs-directory))
#+end_src
**** Makel
I find [[https://github.com/vermiculus/emake.el][emake]] difficult to use, so I have experimentally switched to [[https://gitlab.petton.fr/DamienCassou/makel][makel]].

*** Haskell

#+begin_src emacs-lisp
  (akirak/require 'setup-haskell)
#+end_src

*** Java
#+begin_src emacs-lisp
  (defcustom akirak/java-support-module 'setup-java-lsp
    "Module for supporting Java."
    :type '(choice (const setup-java-lsp)
                   (const setup-java-meghanada)))

  (add-hook 'java-mode-hook (lambda () (require akirak/java-support-module)))

#+end_src
*** JavaScript
#+begin_src emacs-lisp
  (akirak/require 'setup-javascript)
  (akirak/require 'setup-json)
#+end_src
*** Kotlin

#+begin_src emacs-lisp
  (akirak/require 'setup-kotlin)
#+end_src

*** Nim

#+begin_src emacs-lisp
  (akirak/require 'setup-nim)
#+end_src

*** Python
*** Rust
:PROPERTIES:
:CREATED_TIME: [2019-01-01 Tue 15:54]
:ID:       e15d3e74-9760-4e6f-ba18-9cb337758247
:END:
:LOGBOOK:
CLOCK: [2019-01-01 Tue 15:54]--[2019-01-01 Tue 15:56] =>  0:02
:END:
#+begin_src emacs-lisp
  (use-package rust-mode)
#+end_src

*** Shell scripts (bash)
#+begin_src emacs-lisp
  (akirak/require 'setup-shell-scripts)
#+end_src
*** VBScript
:PROPERTIES:
:CREATED_TIME: [2019-05-16 Thu 01:10]
:END:
#+begin_src emacs-lisp
  (akirak/require 'setup-visual-basic)
#+end_src
*** Vue
:PROPERTIES:
:CREATED_TIME: [2019-04-03 Wed 22:45]
:END:
#+begin_src emacs-lisp
  (akirak/require 'setup-vue)
#+end_src
*** Web-mode
#+begin_src emacs-lisp
  (akirak/require 'setup-web-mode)
#+end_src

#+begin_src emacs-lisp
  (akirak/require 'setup-restclient)
#+end_src
** DSLs
:PROPERTIES:
:TOC:      1
:sort:     a
:END:
*** Bats                                               :testing__framework:
:PROPERTIES:
:CREATED_TIME: [2019-07-17 Wed 22:25]
:END:
#+begin_src emacs-lisp
  (use-package bats-mode)
#+end_src
*** Dhall                                         :configuration__language:
#+begin_src emacs-lisp
  (akirak/require 'setup-dhall)
#+end_src
*** Dockerfile                                    :configuration__language:

#+begin_src emacs-lisp
  (akirak/require 'setup-dockerfile)
#+end_src
*** GraphViz                                           :diagramming:org_babel:
#+begin_src emacs-lisp
(akirak/require 'setup-graphviz-dot)
#+end_src
*** Nix                                           :configuration__language:
#+begin_src emacs-lisp
  (akirak/require 'setup-nix)
#+end_src
*** Pug                                                :template__language:
#+begin_src emacs-lisp
  (akirak/require 'setup-pug)
#+end_src
*** Systemd                                       :configuration__language:
#+begin_src emacs-lisp
(akirak/require 'setup-systemd)
#+end_src
*** YAML                                          :configuration__language:
#+begin_src emacs-lisp
  (akirak/require 'setup-yaml)
#+end_src
**** Ansible
#+begin_src emacs-lisp
  (akirak/require 'setup-ansible)
#+end_src
*** CSS
#+begin_src emacs-lisp
  (akirak/require 'setup-css)
#+end_src
** Emacs applications
*** Getting organised
**** Global bindings related to Org mode
 #+begin_src emacs-lisp
   (akirak/bind-key "M-g M-j" #'org-clock-goto)
   (akirak/bind-search
     "M-o" #'helm-org-rifle-known-files
     "M-h" #'org-recent-headings-helm)
   (akirak/bind-jump "M-o" #'org-starter-find-file-by-key)
   (akirak/bind-user
     "c" #'org-capture
     "l" 'org-store-link)
 #+end_src
***** On navigation
#+begin_src emacs-lisp
  (akirak/require 'setup-org-recent-headings)
#+end_src
**** Org Journal
#+begin_src emacs-lisp
  (akirak/require 'setup-org-journal)
#+end_src
**** Frame
:PROPERTIES:
:ID:       5c418e70-a0a0-4d86-81a5-3186abb038ee
:END:

#+begin_src emacs-lisp
  (akirak/define-frame-workflow "org"
    :key "o"
    :layout '(progn
               (org-starter-load-all-known-files)
               (when (fboundp #'ibuffer-sidebar-show-sidebar)
                 (ibuffer-sidebar-show-sidebar)
                 (with-current-buffer (ibuffer-sidebar-buffer (selected-frame))
                   (ibuffer-projectile-set-filter-groups)
                   (ibuffer-update nil))))
    :make-frame '(frame-purpose-make-mode-frame 'org-mode))
#+end_src

**** Org-agenda keybindings                              :Emacs:Org__Mode:
:PROPERTIES:
:CREATED_TIME: [2019-01-19 Sat 12:22]
:END:
:LOGBOOK:
CLOCK: [2019-01-19 Sat 12:22]--[2019-01-19 Sat 12:25] =>  0:03
:END:

#+begin_src emacs-lisp
  (general-def org-agenda-mode-map :package 'org-agenda
    "M-n" #'org-agenda-drag-line-forward
    "M-p" #'org-agenda-drag-line-backward)
#+end_src
*** Beancount
#+begin_src emacs-lisp
  (akirak/require 'setup-beancount)
#+end_src
*** System tools
**** System services
#+begin_src emacs-lisp
;; Run (root) systemd operations
(use-package helm-systemd :after helm
  :commands (helm-systemd))
#+end_src

I'm not using the following packages:

#+begin_src emacs-lisp
  ;; Manage docker services
  (use-package docker
    :disabled t)
  ;; Manage daemons
  (use-package prodigy
    :disabled t)
#+end_src
**** Mounting disks
#+begin_src emacs-lisp
(use-package helm-linux-disks
  :straight (helm-linux-disks :host github
                              :repo "akirak/helm-linux-disks")
  :commands (helm-linux-disks)
  :custom
  (linux-disk-terminal-type 'akirak/shell-new))
#+end_src
**** Disk usage
#+begin_src emacs-lisp
(use-package disk-usage
  :general
  (:keymaps 'akirak/system-map
            "D" 'disk-usage))
#+end_src
** Multiple major modes
Some package need to be loaded after other packages, so they are put here.
*** polymode
This could be useful, but I am not using any of the derived modes for now.
#+begin_src emacs-lisp
  ;; (akirak/require 'setup-polymode)
#+end_src
** EXWM
#+begin_src emacs-lisp
  (when (member "--exwm" command-line-args)
    (akirak/require 'setup-exwm)
    (exwm-enable))

  (add-to-list 'command-switch-alist '("--exwm" . (lambda (_) nil)))
#+end_src

When you connect/disconnect to an external monitor, run =akirak/exwm-configure-screens= command, unless it is automatically called by the screen change hook.
I use EXWM for development both on Chrome OS (at home) and on NixOS (at work).
*** Slack
I use Slack inside EXWM at work.

#+begin_src emacs-lisp
  (defcustom akirak/slack-app-url ""
    "URL to the Slack workspace I am working for."
    :type 'string)

  (defun akirak/exwm-open-slack-this-workspace ()
    (interactive)
    (akirak/exwm-raise-web-app akirak/slack-app-url
                               #'akirak/exwm-select-buffer-window))

  (frame-workflow-define-subject "slack"
    :key "S"
    :layout
    '(akirak/exwm-open-slack-this-workspace)
    :refocus
    '(akirak/exwm-open-slack-this-workspace)
    :after-kill-buffer
    '(delete-frame))
#+end_src
*** Visual Studio Code
I use Visual Studio Code for work.

#+begin_src emacs-lisp
  (defun akirak/raise-vscode-here ()
    (interactive)
    (akirak/exwm-raise-desktop-app "code.desktop"
                                   'akirak/exwm-select-buffer-window))

  (frame-workflow-define-subject "vscode"
    :key "V"
    :layout
    '(akirak/raise-vscode-here)
    :refocus
    '(akirak/raise-vscode-here)
    :after-kill-buffer
    '(delete-frame))
#+end_src
*** Web browser
#+begin_src emacs-lisp
  (akirak/require 'setup-web-browser)
#+end_src

#+begin_src emacs-lisp
  (when (akirak/exwm-session-p)
    (frame-workflow-define-subject "web"
      :key "w"
      :layout
      '(akirak/helm-web-browser)))
#+end_src
** Meta
*** Synchronizing my configuration repositories
I am now using myrepos to synchronize my configuration repositories.

#+begin_src emacs-lisp
  (defun akirak/mr-update ()
    "Run 'mr update' in the home directory."
    (interactive)
    (save-some-buffers)
    (let ((default-directory "~"))
      (akirak/run-interactive-shell-command "mr update")))

  (defalias 'akirak/update-configuration 'akirak/mr-update)
#+end_src

#+begin_src emacs-lisp
  (defun akirak/mr-push ()
    (interactive)
    (let ((default-directory "~"))
      (akirak/run-interactive-shell-command "mr push")))
#+end_src
*** Rebuild packages
#+begin_src emacs-lisp
  (akirak/require 'setup-straight)
#+end_src
*** Sort entries in this file
#+begin_src emacs-lisp
  (defun akirak/org-sort-entries-as-desired ()
    (interactive)
    (org-with-wide-buffer
     (goto-char (point-min))
     (while (re-search-forward (org-re-property "sort") nil t)
       (let ((line (thing-at-point 'line t)))
         (if (string-match org-property-re line)
             (pcase (match-string 3 line)
               ("a" (org-sort-entries nil ?a)))
           (error "Property didn't match")))
       (org-end-of-subtree)))
    (when (org-find-property "TOC")
      (org-make-toc)))
#+end_src
*** Ignore
:PROPERTIES:
:TOC:      ignore
:END:
# Local Variables:
# org-id-link-to-org-use-id: nil
# End:
