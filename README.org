* Emacs Configuration
This is my Emacs configuration.

** Table of contents
:PROPERTIES:
:TOC: siblings
:END:
-  [[#prerequisites][Prerequisites]]
-  [[#installation][Installation]]
-  [[#license][License]]
-  [[#initialization][Initialization]]
  -  [[#configure-straightel][Configure straight.el]]
  -  [[#benchmarking-the-startup-process][Benchmarking the startup process]]
  -  [[#use-the-latest-git-version-of-org-mode][Use the latest Git version of Org mode]]
  -  [[#recipe-overrides][Recipe overrides]]
  -  [[#load-configuration-files][Load configuration files]]
-  [[#configuration][Configuration]]
  -  [[#things-to-set-up-before-using-use-package][Things to set up before using use-package]]
  -  [[#default-settings][Default settings]]
  -  [[#migrating][Migrating]]
-  [[#packages][Packages]]
-  [[#autoloads][Autoloads]]
-  [[#commands-and-keybindings][Commands and keybindings]]
  -  [[#basic-keybindings][Basic keybindings]]
    -  [[#c-a][C-a]]
    -  [[#c-e][C-e]]
    -  [[#c-h][C-h]]
    -  [[#c-w][C-w]]
    -  [[#c-u][C-u]]
    -  [[#c-r][C-r]]
  -  [[#key-translation][Key translation]]
    -  [[#emulate-virtual-function-keys-of-chrome-os][Emulate virtual function keys of Chrome OS]]
  -  [[#switching-buffers][Switching buffers]]
    -  [[#helm-commands][Helm commands]]
    -  [[#browsing-contents-in-specific-buffers-without-leaving-the-context][Browsing contents in specific buffers without leaving the context]]
  -  [[#navigation-in-buffer][Navigation in buffer]]
    -  [[#page-navigation][Page navigation]]
  -  [[#editing][Editing]]
    -  [[#undo-and-redo][Undo and redo]]
    -  [[#editing-source-code-comments-in-org-mode-using-outorg][Editing source code comments in org-mode using outorg]]
  -  [[#running-external-commands][Running external commands]]
  -  [[#maintenance-and-development-of-the-config][Maintenance and development of the config]]
  -  [[#administration][Administration]]
    -  [[#docker][Docker]]
    -  [[#nix][Nix]]

**  Prerequisites
- Linux or Window Subsystem for Linux
- Nix package manager for installing dependencies


**  Installation
This configuration depends on some external programs as well as Emacs
Lisp packages built by Nix.

At present, a suggested installation procedure is to first install my [[https://github.com/akirak/home.nix][home.nix]] and then run =mr checkout= at your home directory.
In the future, it may support an alternative for trying out.


**  License
GPL v3.

Some libraries were originally written by other people, and they
follow their respective licenses.


**  Initialization
#+begin_src emacs-lisp
(when (version< emacs-version "26.1")
  (error "Use GNU Emacs version 26.1 or later"))
#+end_src

Expand the GC threshold until gcmh-mode is activated.
gcmh-mode updates this value later, so you don't have to reset it.
The value is stolen from http://akrl.sdf.org/

#+begin_src emacs-lisp
(setq gc-cons-threshold #x40000000)

(unless (fboundp 'whitespace-cleanup-mode)
  (defun whitespace-cleanup-mode (&rest args)
    (when (require 'whitespace-cleanup-mode nil t)
      (apply #'whitespace-cleanup-mode args))))

(add-to-list 'exec-path (expand-file-name "~/.nix-profile/bin"))

(defconst akirak/to-be-run-as-exwm (member "--exwm" command-line-args))

(defun akirak/exwm-session-p ()
  akirak/to-be-run-as-exwm)
#+end_src

***  Configure straight.el
#+begin_src emacs-lisp
(load-file (expand-file-name "core/straight.el" user-emacs-directory))
#+end_src

Install use-package using straight.el

#+begin_src emacs-lisp
(straight-use-package 'use-package)
#+end_src

Use straight.el by default in use-package directives

#+begin_src emacs-lisp
(setq straight-use-package-by-default t)
#+end_src

***  Benchmarking the startup process
#+begin_src emacs-lisp
(use-package benchmark-init
  :hook
  (after-init . benchmark-init/deactivate))
#+end_src

***  Use the latest Git version of Org mode
#+begin_src emacs-lisp
(require 'cl-lib)
(require 'subr-x)
#+end_src

Remove org-mode shipped with Emacs from load-path

#+begin_src emacs-lisp
(cl-delete-if (lambda (dpath) (string-match-p "/org/?$" dpath)) load-path)
#+end_src

Install org-mode from the Git repository

#+begin_src emacs-lisp
(load-file (expand-file-name "core/org-from-git.el" user-emacs-directory))
#+end_src

***  Recipe overrides
#+begin_src emacs-lisp
(akirak/straight-use-recipes-from-file
 akirak/straight-default-recipes-file)
#+end_src

***  Load configuration files
#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
(require 'my/const/system)
#+end_src

TODO: Move to lisp/

#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name "extras" user-emacs-directory))
#+end_src

**  Configuration
Prevent a confirmation dialog when the org file is loaded.
Don't forget to revert this variable at the beginning of the Org file.

#+begin_src emacs-lisp
(setq-default enable-local-variables :all)
(load-file (expand-file-name "core/setup.el" user-emacs-directory))
#+end_src

***  Things to set up before using =use-package=
#+begin_src emacs-lisp
(akirak/require 'setup-gc)

(setq-default enable-local-variables :safe)
#+end_src

These packages are required in other use-package directives declared in this
configuration.


#+begin_src emacs-lisp
(use-package el-patch
  :custom
  (el-patch-enable-use-package-integration t))
#+end_src

Activate =package.el= for loading built-in packages from nixpkgs:


#+begin_src emacs-lisp
(require 'package)
(package-initialize 'noactivate)
#+end_src

Package-specific configuration files, including snippets, are kept in [[https://github.com/akirak/emacs-config-library][a separate repository]], not in this repository.


#+begin_src emacs-lisp
(use-package no-littering)
#+end_src

Use the executable path from the shell


#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :disabled t
  :if (memq window-system '(mac ns x))
  :init
  (exec-path-from-shell-initialize))
#+end_src

Use diminish to reduce clutters from the modeline. This adds support for =:diminish= keyword:


#+begin_src emacs-lisp
(use-package diminish
  :disabled t
  :init
  (diminish 'auto-revert-mode)
  (diminish 'outline-minor-mode)
  (diminish 'flyspell-mode))

(use-package use-package-company
  ;; Originally written by Foltik, but I use my fork
  :straight (use-package-company :host github :repo "akirak/use-package-company"))

(use-package general)
#+end_src

***  Default settings
#+begin_src emacs-lisp
(require 'setup-defaults)

(when (akirak/running-on-crostini-p)
  (require 'my/system/platform/crostini))
#+end_src

***  Migrating
#+begin_src emacs-lisp
(org-babel-load-file (expand-file-name "main.org" user-emacs-directory))
#+end_src

**  Packages
#+begin_src emacs-lisp
(use-package docker)
(use-package electric
  :straight (:type built-in)
  :hook
  (text-mode . electric-pair-local-mode))

(use-package helm-tail
  :commands (helm-tail))
(use-package org-recent-headings
  :after org
  :config
  (org-recent-headings-mode 1))
(use-package whole-line-or-region)
#+end_src

**  Autoloads
#+begin_src emacs-lisp
(use-package my/project
  :straight (:type built-in))

(use-package my/buffer/predicate
  :straight (:type built-in))
#+end_src

**  Commands and keybindings
***  Basic keybindings
These keybindings basically emulate UNIX shells (i.e. sh, bash,
etc.).

I also like to define "dwim" commands, if applicable, to save the
keybinding space and key strokes.

****  C-a
By default, ~C-a~ is bound to =beginning-of-line=.

This command first jump to the indentation and then visits the
beginning of line.

#+begin_src emacs-lisp
(general-def prog-mode-map
  "C-a"
  (defun akirak/back-to-indentation-or-beginning-of-line ()
    (interactive)
    (if (or (looking-at "^")
            (string-match-p (rx (not (any space)))
                            (buffer-substring-no-properties
                             (line-beginning-position)
                             (point))))
        (back-to-indentation)
      (beginning-of-line))))
#+end_src

In =org-mode=, I prefer =org-beginning-of-line=.

#+begin_src emacs-lisp
(general-def :keymaps 'org-mode-map :package 'org
  "C-a" #'org-beginning-of-line)
#+end_src

****  C-e
#+begin_src emacs-lisp
(general-def :keymaps 'org-mode-map :package 'org
  "C-e" #'org-end-of-line)
#+end_src

****  C-h
#+begin_src emacs-lisp
(general-def
  "C-h" 'backward-delete-char)
#+end_src

****  C-w
#+begin_src emacs-lisp
(general-def
  "C-w"
  (defun akirak/kill-region-or-backward-kill-word (&optional arg)
    "If a region is active, run `kill-region'. Otherwise, run `backward-kill-word'."
    (interactive "p")
    (if (region-active-p)
        (kill-region (region-beginning) (region-end))
      (backward-kill-word arg))))

(general-def minibuffer-local-map
  "C-w" #'backward-kill-word)

(general-def ivy-minibuffer-map :package 'ivy
  "C-w" #'ivy-backward-kill-word)
#+end_src

****  C-u
#+begin_src emacs-lisp
(general-def minibuffer-local-map
  "C-u" #'backward-kill-sentence)

(general-def ivy-minibuffer-map :package 'ivy
  "C-u"
  (defun ivy-backward-kill-sentence ()
    (interactive)
    (if ivy--directory
        (progn (ivy--cd "/")
               (ivy--exhibit))
      (if (bolp)
          (kill-region (point-min) (point))
        (backward-kill-sentence)))))
#+end_src

****  C-r
In minibuffers, ~C-r~ should call history.

#+begin_src emacs-lisp
(general-def ivy-minibuffer-map :package 'ivy
  "C-r" 'counsel-minibuffer-history)
#+end_src

***  Key translation
Since I have bound C-h to =backward-delete-char= but still use the
help system frequently, I bind ~M-`~ to ~<f1>~ in
=key-translation-map=.

#+begin_src emacs-lisp
(general-def key-translation-map
  ;; * Obsolete
  ;; As <menu> (application on Windows keyboards) is hard to reach on some
  ;; keyboards, I will use <C-tab> instead. This key combination is occupied on
  ;; web browsers but vacant on most Emacs major modes, so it is safe to use it
  ;; on non-EXWM buffers.
  ;; "<C-tab>" (kbd "<menu>")

  ;; Chromebook don't have physical function keys. They substitute
  ;; Search + num for function keys, but Search + 1 is hard to press,
  ;; especially when Search and Ctrl are swapped.
  ;; This is quite annoying, so I will use M-` as <f1>.
  "M-`" (kbd "<f1>"))
#+end_src

****  Emulate virtual function keys of Chrome OS
Emulate function keys of Chrome OS, i.e. use ~s-NUM~ as function
keys.

#+begin_src emacs-lisp
(define-globalized-minor-mode akirak/emulate-chromeos-fnkey-mode
  nil
  (lambda ()
    (cond
     (akirak/emulate-chromeos-fnkey-mode
      (dolist (n (number-sequence 1 9))
        (define-key key-translation-map
          (kbd (format "s-%d" n)) (kbd (format "<f%d>" n))))
      (define-key key-translation-map
        (kbd "s-0") (kbd "<f10>"))
      (define-key key-translation-map
        (kbd "s--") (kbd "<f11>"))
      (define-key key-translation-map
        (kbd "s-=") (kbd "<f12>")))
     (t
      (dolist (n (number-sequence 0 9))
        (define-key key-translation-map
          (kbd (format "s-%d" n)) nil))
      (define-key key-translation-map
        (kbd "s--") nil)
      (define-key key-translation-map
        (kbd "s-=") nil)))))

(unless (akirak/running-on-crostini-p)
  (akirak/emulate-chromeos-fnkey-mode 1))
#+end_src

***  Switching buffers
Switching buffers is the most essential operation in Emacs.
Most of these commands are bound on C-x.

****  Helm commands
#+begin_src emacs-lisp
(general-def
  "C-x b"
  (defun akirak/switch-to-project-file-buffer (project)
    (interactive (list (if current-prefix-arg
                           'all
                         (-some-> (project-current)
                           (project-roots)
                           (car-safe)))))
    (require 'my/helm/action/git)
    (cond
     ((eq project 'all)
      (helm-buffers-list))
     (t
      (let ((default-directory (or project default-directory)))
        (helm :prompt (format "Project %s: " project)
              :sources
              `(,@(akirak/helm-project-buffer-sources project #'akirak/switch-to-project-file-buffer)
                ,akirak/helm-source-recent-files
                ,(helm-make-source "Git repositories" 'akirak/helm-source-magit-repos
                   :action (cons '("Switch to project" . akirak/switch-to-project-file-buffer)
                                 akirak/helm-git-project-actions))))))))
  "C-x p"
  (defun akirak/find-file-recursively (root)
    (interactive (list (if current-prefix-arg
                           (read-directory-name "Find files in dir: ")
                         (akirak/project-root default-directory))))
    (require 'my/helm/source/file)
    (let ((default-directory root))
      (helm :prompt (format "Browse %s: " root)
            :sources
            (list akirak/helm-source-project-files
                  akirak/helm-source-dummy-find-file))))
  "C-x d"
  (defun akirak/switch-to-dired-buffer ()
    (interactive)
    (pcase current-prefix-arg
      ('(16) (helm :prompt "Git repositories: "
                   :sources akirak/helm-magic-list-repos-source))
      ('(4)
       (if-let (root (akirak/project-root default-directory))
           (let ((default-directory root))
             (helm :prompt "Project: "
                   :sources akirak/helm-project-root-and-ancestors-source))
         (error "Not implemented for outside of a project")))
      ('()
       (helm :prompt "Switch to a dired buffer: "
             :sources
             (list (akirak/helm-dired-buffer-source)
                   akirak/helm-open-buffer-directories-source
                   akirak/helm-directory-bookmark-source)))))
  "C-x j"
  (defun akirak/switch-to-org-buffer ()
    (interactive)
    (require 'helm-org-ql)
    (require 'org-recent-headings)
    (helm :prompt "Switch to Org: "
          :sources
          (list (akirak/helm-indirect-org-buffer-source)
                helm-source-org-recent-headings
                akirak/helm-source-org-starter-known-files
                helm-source-org-ql-views)))
  "C-x x"
  (defun akirak/switch-to-x-buffer (&optional arg)
    (interactive "P")
    (cond
     ((akirak/exwm-session-p)
      (helm :prompt "Switch to EXWM buffer: "
            :sources (akirak/helm-exwm-buffer-source)))
     ((akirak/windows-subsystem-for-linux-p)
      (user-error "Not supported on WSL"))
     ((eq system-type 'linux)
      ;; TODO: Implement it
      (cl-assert (executable-find "wmctrl"))
      (helm :prompt "X window: "
            :source
            (helm-build-sync-source "X windows"
              :candidates (-map (lambda (s) (cons s (car (s-split-words s))))
                                (process-lines "wmctrl" "-l"))
              :action (lambda (wid)
                        (async-start-process "wmctrl" "wmctrl" nil
                                             "-a" wid)))))))
  "C-x '"
  (defun akirak/switch-to-reference-buffer ()
    (interactive)
    (helm :prompt "Switch to a reference buffer: "
          :sources (akirak/helm-reference-buffer-source))))
#+end_src

In the list of project buffers, you can switch to a file list with
~M-/~.

#+begin_src emacs-lisp
(general-def
  :keymaps 'akirak/helm-project-buffer-map
  :package 'my/helm/source/complex
  "M-/" (lambda ()
          (interactive)
          (helm-run-after-quit
           (lambda ()
             (akirak/find-file-recursively default-directory)))))
#+end_src

I haven't bound any key to this command yet.

#+begin_src emacs-lisp
(defun akirak/switch-to-scratch-buffer ()
  (interactive)
  (helm :prompt "Switch to a scratch/REPL buffer: "
        :sources
        (akirak/helm-scratch-buffer-source)))
#+end_src

****  Browsing contents in specific buffers without leaving the context
#+begin_src emacs-lisp
(general-def
  ;; This command lets you browse lines in error buffers.
  "C-x t" #'helm-tail)
#+end_src

***  Navigation in buffer
****  Page navigation
I will use ~C-x [~ and ~C-x ]~ for "page" navigation. These keys
are bound to =backward-page= and =forward-page= by default, but
they should be rebound depending on the major mode, since the
notion of page/chunk varies.


#+begin_src emacs-lisp
(general-def
  ;; Default
  "C-x [" #'backward-page
  "C-x ]" #'forward-page)

(general-def :keymaps 'org-mode-map :package 'org
  ;; [remap backward-page]
  [remap forward-page]
  (defun akirak/org-narrow-to-next-sibling-subtree ()
    (interactive)
    (if (buffer-narrowed-p)
        (let ((old-level (save-excursion
                           (goto-char (point-min))
                           (org-outline-level)))
              (end (point-max)))
          (goto-char (point-max))
          (widen)
          (if (re-search-forward org-heading-regexp nil t)
              (let ((new-level (org-outline-level)))
                (org-narrow-to-subtree)
                (org-back-to-heading)
                (org-show-subtree)
                (cond
                 ((= new-level old-level)
                  (message "Narrowing to the next sibling"))
                 ((> new-level old-level)
                  (message "Narrowing to a child"))
                 ((< new-level old-level)
                  (message "Narrowing to an upper level"))))
            (message "No more heading")))
      (message "Buffer is not narrowed"))))
#+end_src

***  Editing
****  Undo and redo
You still can use the built-in undo command with C-x u

#+begin_src emacs-lisp
(use-package undo-fu
  :general
  ("C-/" #'undo-fu-only-undo
   "C-?" #'undo-fu-only-redo))
#+end_src

****  Editing source code comments in org-mode using outorg
Bind ~C-c '~ to outorg, which is the same keybinding as =org-edit-special=.

#+begin_src emacs-lisp
(use-package outorg
  :commands (outorg-edit-as-org)
  :config/el-patch
  (el-patch-defun outorg-convert-oldschool-elisp-buffer-to-outshine ()
    "Transform oldschool elisp buffer to outshine.
In `emacs-lisp-mode', transform an oldschool buffer (only
semicolons as outline-regexp) into an outshine buffer (with
outcommented org-mode headers)."
    (save-excursion
      (goto-char (point-min))
      (when (outline-on-heading-p)
        (outorg-convert-oldschool-elisp-headline-to-outshine))
      (while (not (eobp))
        (outline-next-heading)
        (outorg-convert-oldschool-elisp-headline-to-outshine)))
    (el-patch-remove (funcall 'outshine-hook-function))))
(general-def :keymaps 'emacs-lisp-mode-map
  "C-c '" #'outorg-edit-as-org)
(general-def :keymaps 'outorg-edit-minor-mode-map :package 'outorg
  "C-c '" #'outorg-copy-edits-and-exit)
#+end_src

***  Running external commands
#+begin_src emacs-lisp
(general-def
  "C-x c"
  (defun akirak/compile-command (&optional arg)
    (interactive "P")
    (require 'my/compile)
    (cl-labels
        ((spago-root
          ()
          (locate-dominating-file default-directory "spago.dhall"))
         (spago-build
          (root)
          (let ((command (completing-read "PureScript spago command: "
                                          akirak/spago-compile-command-list)))
            (akirak/compile command :directory root)))
         (make-root
          ()
          (locate-dominating-file default-directory "Makefile"))
         (npm-root
          ()
          (locate-dominating-file default-directory "package.json"))
         (npm-run-something
          (root)
          (progn
            (require 'my/compile/npm)
            (let ((script-alist (akirak/npm-package-json-commands (f-join root "package.json")))
                  (default-directory root)
                  (action (lambda (command)
                            (akirak/compile (concat "npm " command)
                                            :nix-shell-args (unless (executable-find "npm")
                                                              '("-p" "nodejs"))))))
              (helm :prompt (format "npm command [%s]: " root)
                    :sources
                    (list (helm-build-sync-source "Script"
                            :candidates
                            (-map (lambda (cell)
                                    (cons (format "%s: %s" (car cell) (cdr cell))
                                          (cdr cell)))
                                  script-alist)
                            :coerce (-partial #'s-append "run ")
                            :action action)
                          (helm-build-sync-source "Basic commands"
                            :candidates
                            '("install")
                            :coerce (-partial #'s-append "run ")
                            :action action)))))))
      (let (root)
        (cond
         ((and (derived-mode-p 'purescript-mode)
               (setq root (spago-root)))
          (spago-build root))
         ((equal arg '(4))
          (helm :prompt "Compile history: "
                :sources akirak/helm-compile-history-source)
          (akirak/helm-shell-command))
         ((equal arg 0)
          (let ((root (akirak/project-root default-directory)))
            (if (and root (f-exists (f-join root ".github"))
                     (executable-find "act"))
                (let ((default-directory root))
                  (compile "act"))
              (user-error "N/A"))))
         ((make-root)
          (counsel-compile))
         ((setq root (npm-root))
          (npm-run-something root))))))
  "C-x C"
  (defun akirak/helm-shell-command ()
    (interactive)
    (require 'my/helm/source/org)
    (require 'my/helm/action/org-marker)
    (let ((root (or (akirak/project-root default-directory)
                    default-directory)))
      (setq akirak/programming-recipe-mode-name "sh"
            akirak/helm-org-ql-buffers-files (org-multi-wiki-entry-files 'organiser :as-buffers t))
      (helm :prompt (format "Execute command (project root: %s): " root)
            :sources
            (helm-make-source "Command" 'akirak/helm-source-org-ql-src-block
              :action akirak/helm-org-marker-sh-block-action-list)))))
#+end_src

***  Maintenance and development of the config
These commands are used to maintain this Emacs configuration.

#+begin_src emacs-lisp
(general-def
  "C-x M-m"
  (defun akirak/helm-my-library ()
    "Browse the library for this configuration."
    (interactive)
    (require 'my/helm/source/file)
    (let ((default-directory (f-join user-emacs-directory "lisp")))
      (helm :prompt (format "Files in %s: " default-directory)
            :sources (list (helm-make-source "Files in project"
                               'akirak/helm-source-project-file)
                           (helm-build-dummy-source "New file in lisp directory"
                             :action #'find-file))))))
#+end_src

***  Administration
****  Docker
#+begin_src emacs-lisp
(akirak/bind-admin
  "k" '(nil :wk "docker")
  "ki" #'docker-images
  "kk" #'docker-containers
  "kn" #'docker-networks
  "kv" #'docker-volumes)
#+end_src

****  Nix
#+begin_src emacs-lisp
(akirak/bind-admin
  "n" '(nil :wk "nix")
  "nC" #'nix-env-install-cachix-use
  "nn" #'nix-env-install-npm
  "nu" #'nix-env-install-uninstall)
#+end_src

